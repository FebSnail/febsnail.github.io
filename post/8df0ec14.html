<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Java学习 | 二月蜗牛2</title><meta name="author" content="FebSnail"><meta name="copyright" content="FebSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="说明： ▲：不大会、不大理解 ☆：自己的理解 ★：重点 🔺：不懂 第一章、Java语言概述Java基础知识图解  第二章、Java基本语法2.1 变量与运算符2.1.1 关键字与保留字  定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）   特点：关键字中所有字母都为小写      static解析1、static关键字的用途  static方法一般称作静态方法，由于静态方法不依">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习">
<meta property="og:url" content="https://febsnail.github.io/post/8df0ec14.html">
<meta property="og:site_name" content="二月蜗牛2">
<meta property="og:description" content="说明： ▲：不大会、不大理解 ☆：自己的理解 ★：重点 🔺：不懂 第一章、Java语言概述Java基础知识图解  第二章、Java基本语法2.1 变量与运算符2.1.1 关键字与保留字  定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）   特点：关键字中所有字母都为小写      static解析1、static关键字的用途  static方法一般称作静态方法，由于静态方法不依">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-29T07:13:23.000Z">
<meta property="article:modified_time" content="2023-03-29T07:21:44.983Z">
<meta property="article:author" content="FebSnail">
<meta property="article:tag" content="遗憾吗关于她">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://febsnail.github.io/post/8df0ec14.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-29 15:21:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="二月蜗牛2"><span class="site-name">二月蜗牛2</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T07:13:23.000Z" title="发表于 2023-03-29 15:13:23">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-29T07:21:44.983Z" title="更新于 2023-03-29 15:21:44">2023-03-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>说明：</p>
<p>▲：不大会、不大理解</p>
<p>☆：自己的理解</p>
<p>★：重点</p>
<p>🔺：不懂</p>
<h1 id="第一章、Java语言概述"><a href="#第一章、Java语言概述" class="headerlink" title="第一章、Java语言概述"></a>第一章、Java语言概述</h1><h2 id="Java基础知识图解"><a href="#Java基础知识图解" class="headerlink" title="Java基础知识图解"></a>Java基础知识图解</h2><img src="/post/8df0ec14/1668044658642-002044b7-02b5-41d0-8235-a516bd2e579e.png" class="" title="image-20220325100945511.png">

<h1 id="第二章、Java基本语法"><a href="#第二章、Java基本语法" class="headerlink" title="第二章、Java基本语法"></a>第二章、Java基本语法</h1><h2 id="2-1-变量与运算符"><a href="#2-1-变量与运算符" class="headerlink" title="2.1 变量与运算符"></a>2.1 变量与运算符</h2><h4 id="2-1-1-关键字与保留字"><a href="#2-1-1-关键字与保留字" class="headerlink" title="2.1.1 关键字与保留字"></a>2.1.1 关键字与保留字</h4><ul>
<li> 定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词） </li>
<li> 特点：关键字中所有字母都为小写 </li>
</ul>
<img src="/post/8df0ec14/1668172089224-c568febb-7715-4f96-b78c-4f3e6ffc056a.png" class="" title="image-20220325100951579.png">
<img src="/post/8df0ec14/1668172094596-cb8bc62b-b3a3-47f3-bb9e-e903d5e6addb.png" class="" title="image-20220325100954023.png">

<h5 id="static解析"><a href="#static解析" class="headerlink" title="static解析"></a>static解析</h5><h6 id="1、static关键字的用途"><a href="#1、static关键字的用途" class="headerlink" title="1、static关键字的用途"></a>1、static关键字的用途</h6><ul>
<li> static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 </li>
<li></li>
</ul>
<blockquote>
<p>注意：在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。</p>
</blockquote>
<p>举例如下 </p>
<ul>
<li><img src="/post/8df0ec14/1668172110392-d388f4bc-57b5-447a-bcf5-fb24537b1880.png" class="" title="image-20220407082131096.png"> 
<ul>
<li>上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。</li>
</ul>
</li>
<li> 还有一点就是构造器不是static，静态方法中不能使用this，而构造器中可以使用this关键字，故构造器不是static </li>
<li>static变量 <ul>
<li>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
<li>static成员变量的初始化顺序按照定义的顺序进行初始化。</li>
</ul>
</li>
<li>static代码块（可以用来优化程序性能，减少重复的空间浪费） <ul>
<li>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li>
<li></li>
</ul>
</li>
</ul>
<h6 id="2、static关键字的误区"><a href="#2、static关键字的误区" class="headerlink" title="2、static关键字的误区"></a>2、static关键字的误区</h6><ol>
<li>static关键字会改变类中成员的访问权限吗？ <ul>
<li>Java中的<strong>static关键字不会影响到变量或者方法的作用域</strong>。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。</li>
</ul>
</li>
<li>能通过this访问静态成员变量吗？ <ul>
<li>静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，<strong>所有的静态方法和静态变量都可以通过对象访问</strong>（只要访问权限足够）。</li>
</ul>
</li>
<li>static 能作用于局部变量么？ <ul>
<li>static是不允许用来修饰局部变量。（Java语法的规定）</li>
</ul>
</li>
</ol>
<p>注：<strong>static块可以出现类中的任何地方</strong>（只要不是方法内部，记住，<strong>任何方法内部都不行</strong>），并且执行是按照static块的顺序执行的。</p>
<h4 id="2-1-2-标识符"><a href="#2-1-2-标识符" class="headerlink" title="2.1.2 标识符"></a>2.1.2 标识符</h4><ul>
<li> Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 </li>
<li> 技巧：凡是自己可以起名字的地方都叫标识符。 </li>
</ul>
<p>定义合法标识符<strong>规则</strong>;</p>
<ul>
<li>由26个英文字母大小写，0-9 ，_或 $ 组成</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格。</li>
</ul>
<p>Java中名称命名<strong>规范</strong>：</p>
<ul>
<li>包名：多单词组成时所有字母都小写：xxxyyyzzz</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个 单词首字母大写：xxxYyyZzz</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
<p>tips:起名字时，尽量“见名知意”</p>
<h4 id="2-1-3-变量"><a href="#2-1-3-变量" class="headerlink" title="2.1.3 变量"></a>2.1.3 变量</h4><p>概念：</p>
<ul>
<li>内存中的一个存储区域</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</li>
</ul>
<p>变量的作用：</p>
<ul>
<li>用于在内存中保存数据</li>
</ul>
<p>使用变量注意点：</p>
<ul>
<li>Java中每个变量必须先声明，后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对{ }内</li>
<li>变量只有在其作用域内才有效</li>
<li>同一个作用域内，不能定义重名的变量</li>
</ul>
<p>声明变量：</p>
<ul>
<li>语法：&lt;数据类型&gt; &lt;变量名称&gt;</li>
<li>例 ：int value;</li>
</ul>
<p>变量的赋值：</p>
<ul>
<li>语法：&lt;变量名称&gt; = &lt;值&gt;</li>
<li>例 ：value= 1；</li>
</ul>
<p>声明变量赋值：</p>
<ul>
<li>语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;</li>
<li>例 ：int value= 10;</li>
</ul>
<h5 id="变量的分类："><a href="#变量的分类：" class="headerlink" title="变量的分类："></a>变量的分类：</h5><img src="/post/8df0ec14/1668172154979-80a3cb03-f289-4311-aae9-a03a4c9d41bb.png" class="" title="image-20220325100958860.png">

<ul>
<li>按位置不同可分 成员变量和局部变量 <ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量。</li>
<li>tip：二者在初始化值方面的异同: <ul>
<li>同：都有生命周期    异：局部变量除形参外，需显式初始化（赋值）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/post/8df0ec14/1668172202374-ac9331e7-e221-4dd7-86e3-447efea04418.png" class="" title="image-20220325101001564.png">

<h5 id="整数类型：byte、short、int、long"><a href="#整数类型：byte、short、int、long" class="headerlink" title="整数类型：byte、short、int、long"></a>整数类型：byte、short、int、long</h5><ul>
<li> Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保 证java程序的可移植性。 </li>
<li> java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’ </li>
<li> java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long  </li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节=8bit位</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-2 15 ~215 -1</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2 31 ~ 231 -1 (约21亿)</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-2 63 ~ 263 -1</td>
</tr>
</tbody></table>
<h5 id="浮点类型：float、double"><a href="#浮点类型：float、double" class="headerlink" title="浮点类型：float、double"></a>浮点类型：float、double</h5><ul>
<li>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操作 系统的影响。</li>
<li>浮点型常量有两种表示形式：</li>
<li>十进制数形式：如：5.12 512.0f .512 (必须有小数点）</li>
<li>科学计数法形式:如：5.12e2 512E2 100E-2</li>
<li>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。 double:双精度，精度是float的两倍。通常采用此类型。</li>
<li>Java 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody><tr>
<td>单精度float</td>
<td>4字节</td>
<td>-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td>双精度double</td>
<td>8字节</td>
<td></td>
</tr>
</tbody></table>
<h5 id="字符类型：char"><a href="#字符类型：char" class="headerlink" title="字符类型：char"></a>字符类型：char</h5><ul>
<li>char 型数据用来表示通常意义上“字符”(2字节) Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字 母，一个汉字，或其他书面语的一个字符。 字符型变量的三种表现形式： <ul>
<li>字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 = ‘a’; char c2  = ‘中’; char c3 = ‘9’;</li>
<li>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。 例如：char c3 = ‘\n’; // ‘\n’表示换行符</li>
<li>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表 一个十六进制整数。如：\u000a 表示 \n。</li>
<li>char类型是可以进行运算的。因为它都对应有Unicode码。</li>
</ul>
</li>
</ul>
<h5 id="了解ASCII-码"><a href="#了解ASCII-码" class="headerlink" title="了解ASCII 码:"></a>了解ASCII 码:</h5><ul>
<li>在计算机内部，所有数据都使用二进制表示。每一个二进制位（bit）有 0 和 1 两种状态， 因此 8 个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。一个字节一 共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从 0000000 到 11111111。</li>
<li>ASCII码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的 关系，做了统一规定。这被称为ASCII码。ASCII码一共规定了128个字符的编码，比如 空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这 128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前 面的1位统一规定为0。</li>
<li>缺点： <ul>
<li>不能表示所有字符。</li>
<li>相同的编码表示的字符不一样：比如，130在法语编码中代表了é，在希伯来语编码中却代表 (ג) 了字母Gime</li>
</ul>
</li>
</ul>
<h5 id="布尔类型：boolean"><a href="#布尔类型：boolean" class="headerlink" title="布尔类型：boolean"></a>布尔类型：boolean</h5><ul>
<li>boolean 类型用来判断逻辑条件，一般用于程序流程控制： <ul>
<li>if条件控制语句；</li>
<li>while循环控制语句；</li>
<li>do-while循环控制语句；</li>
<li>for循环控制语句；</li>
</ul>
</li>
<li>boolean类型数据只允许取值true和false，无null。 <ul>
<li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li>
<li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的 boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false 用0表示。———《java虚拟机规范 8版》</li>
</ul>
</li>
</ul>
<h5 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h5><ul>
<li>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容 量大小排序为： <img src="/post/8df0ec14/1668172231264-d452600b-f56f-4e12-b989-b97d70190917.png" class="" title="image-20220325101007660.png"> </li>
<li> 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的 那种数据类型，然后再进行计算。 </li>
<li> byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。 </li>
<li> boolean类型不能与其它数据类型运算。 </li>
<li> 当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类 型的值将自动转化为字符串(String)类型。 </li>
</ul>
<h5 id="字符串类型：String"><a href="#字符串类型：String" class="headerlink" title="字符串类型：String"></a>字符串类型：String</h5><ul>
<li>String不是基本数据类型，属于引用数据类型</li>
<li>使用方式与基本数据类型一致。例如：String str = “abcd”;</li>
<li>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如str = str + “xyz” ;  int n = 100; str = str + n；</li>
</ul>
<h5 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h5><ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使 用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</li>
<li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可 以实现把字符串转换成基本类型。</li>
<li>如： String a = “43”; int i = Integer.parseInt(a);</li>
<li>boolean类型不可以转换为其它的数据类型。</li>
</ul>
<h5 id="▲进制："><a href="#▲进制：" class="headerlink" title="▲进制："></a>▲进制：</h5><ul>
<li> 所有数字在计算机底层都以二进制形式存在。 </li>
<li>对于整数，有四种表示方式： <ul>
<li> 二进制(binary)：0,1 ，满2进1.以0b或0B开头。 </li>
<li> 十进制(decimal)：0-9 ，满10进1。 </li>
<li> 八进制(octal)：0-7 ，满8进1. 以数字0开头表示。 </li>
<li> 十六进制(hex)：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。 如：0x21AF +1= 0X21B0 </li>
<li> 图示：<img src="/post/8df0ec14/1668172241038-252548e7-2f35-4277-92fa-982c3908dc45.png" class="" title="image-20220325101018933.png"> </li>
</ul>
</li>
<li> Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位； 当是long类型时，二进制默认占64位，第64位是符号位 </li>
<li>二进制的整数有如下三种形式： <ul>
<li>原码：直接将一个数值换成二进制数。最高位是符号位</li>
<li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li>
<li>负数的补码：其反码加1。</li>
</ul>
</li>
</ul>
<h5 id="☆注：进制的具体内容需要再去了解学习，暂时留着"><a href="#☆注：进制的具体内容需要再去了解学习，暂时留着" class="headerlink" title="☆注：进制的具体内容需要再去了解学习，暂时留着"></a>☆注：进制的具体内容需要再去了解学习，暂时留着</h5><h4 id="2-1-4-运算符"><a href="#2-1-4-运算符" class="headerlink" title="2.1.4 运算符"></a>2.1.4 运算符</h4><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><ul>
<li>图解：</li>
</ul>
<img src="/post/8df0ec14/1668172253941-09a70ad4-8057-4d36-8fec-7f25423f6596.png" class="" title="image-20220325101022722.png">

<ul>
<li>如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。 但被模数是 负数则不可忽略。此外，取模运算的结果不一定总是整数。</li>
<li>对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只 保留整数部分而舍弃小数部分。</li>
</ul>
<h5 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符：="></a>赋值运算符：=</h5><p>符号：=</p>
<ul>
<li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制 类型转换原则进行处理。</li>
<li>支持连续赋值。</li>
</ul>
<p>扩展赋值运算符： +=, -=, *=, /=, %=</p>
<ul>
<li>分别对应：加等于  减等于 乘等于 除等于 取模等于</li>
</ul>
<h5 id="比较运算符："><a href="#比较运算符：" class="headerlink" title="比较运算符：=="></a>比较运算符：==</h5><img src="/post/8df0ec14/1668172265670-a7e84e2c-9aaa-4a0a-ab9d-62e9c2708b3c.png" class="" title="image-20220325101025780.png">

<ul>
<li>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</li>
<li>比较运算符“==”不能误写成“=” 。</li>
</ul>
<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>&amp; — 逻辑与     | —逻辑或     ！—逻辑非     &amp;&amp; —短路与</p>
<p>|| —短路或     ^ —逻辑异或</p>
<img src="/post/8df0ec14/1668172273096-ae080ee9-abc0-4f2c-9d2d-f664c669d0df.png" class="" title="image-20220325101028474.png">

<h6 id="★“-amp-”和“-amp-amp-”的区别："><a href="#★“-amp-”和“-amp-amp-”的区别：" class="headerlink" title="★“&amp;”和“&amp;&amp;”的区别："></a>★“&amp;”和“&amp;&amp;”的区别：</h6><ul>
<li>单&amp;时，左边无论真假，右边都进行运算；</li>
<li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li>
</ul>
<h6 id="★“-”和“-”的区别同理，-表示：当左边为真，右边不参与运算。"><a href="#★“-”和“-”的区别同理，-表示：当左边为真，右边不参与运算。" class="headerlink" title="★“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。"></a>★“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</h6><h5 id="位运算符（较少接触，需要再回头学习）"><a href="#位运算符（较少接触，需要再回头学习）" class="headerlink" title="位运算符（较少接触，需要再回头学习）"></a>位运算符（较少接触，需要再回头学习）</h5><img src="/post/8df0ec14/1668172727657-86285f70-440c-4486-b19b-a269d6beea80.png" class="" title="image-20220325101031090.png">

<img src="/post/8df0ec14/1668172733653-b0a79fec-4e62-47cc-b474-788f6eab740b.png" class="" title="image-20220325101034844.png">

<h5 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h5><ul>
<li>(条件表达式)?表达式1：表达式2； <ul>
<li>为true，运算后的结果是表达式1；</li>
<li>为false，运算后的结果是表达式2；</li>
<li>三元运算符与if-else的联系与区别： <ul>
<li>三元运算符可简化if-else语句</li>
<li>三元运算符要求必须返回一个结果。</li>
<li>if后的代码块可有多个语句</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="运算符的优先级："><a href="#运算符的优先级：" class="headerlink" title="运算符的优先级："></a>运算符的优先级：</h5><img src="/post/8df0ec14/1668172779890-8323b3c3-c098-46b3-a545-d15fbe4fe09d.png" class="" title="image-20220325101038560.png">

<h4 id="2-1-5-程序流程控制"><a href="#2-1-5-程序流程控制" class="headerlink" title="2.1.5 程序流程控制"></a>2.1.5 程序流程控制</h4><p>三种基本流程结构：</p>
<ul>
<li>顺序结构</li>
<li>分支结构</li>
<li>循环结构</li>
</ul>
<h6 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h6><ul>
<li>程序从上到下逐行地执行，中间没有任何判断和跳转。</li>
</ul>
<h6 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h6><ul>
<li> 根据条件，选择性地执行某段代码。 </li>
<li> 有if…else和switch-case两种分支语句。 </li>
<li> if-else结构： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123; 执行代码块<span class="number">1</span>; &#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>)&#123; 执行代码块<span class="number">2</span>; </span><br><span class="line">&#125; </span><br><span class="line">  …… </span><br><span class="line">  <span class="keyword">else</span>&#123; 执行代码块n;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量</li>
<li>语句块只有一条执行语句时，一对{}可以省略，但建议保留</li>
<li>if-else语句结构，根据需要可以嵌套使用</li>
<li>当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略</li>
<li>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓 当多个条件是“包含”关系时，“小上大下 / 子上父下”</li>
<li><h2 id="switch-case结构"><a href="#switch-case结构" class="headerlink" title="switch-case结构 "></a>switch-case结构 </h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">语句<span class="number">1</span>;</span><br><span class="line"><span class="comment">// break;</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">// break;</span></span><br><span class="line">… …</span><br><span class="line"><span class="keyword">case</span> 常量N:</span><br><span class="line">语句N;</span><br><span class="line"><span class="comment">// break;</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">语句;</span><br><span class="line"><span class="comment">// break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/post/8df0ec14/1668174693263-3e0b3893-e4ba-4f29-a6d6-978efce32bed.png" class="" title="image-20220325101043256.png">

<ul>
<li> switch(表达式)中表达式的值必须是下述几种类型之一：byte，short， char，int，枚举 (jdk 5.0)，String (jdk 7.0)； </li>
<li> case子句中的值必须是常量，不能是变量名或不确定的表达式值； </li>
<li> 同一个switch语句，所有case子句中的常量值互不相同； </li>
<li> break语句用来在执行完一个case分支后使程序跳出switch语句块；如 果没有break，程序会顺序执行到switch结尾 </li>
<li> default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时， 执行defaul </li>
</ul>
<h6 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h6><blockquote>
<p>在某些条件满足的情况下，反复执行特定代码的功能</p>
</blockquote>
<p>分三类：for 循环        while 循环         do-while 循环</p>
<ul>
<li>for 循环 <ul>
<li> <img src="/post/8df0ec14/1668174765274-9a7a1d08-8388-4a17-967f-8bd617e89b26.png" class="" title="image-20220325101047710.png"> </li>
<li>说明： <ul>
<li>②循环条件部分为boolean类型表达式，当值为false时，退出循环</li>
<li>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</li>
<li>④可以有多个变量更新，用逗号分隔</li>
</ul>
</li>
</ul>
</li>
<li>while循环 <ul>
<li> <img src="/post/8df0ec14/1668174780914-8dfe4484-7ee8-46a6-b2dc-6b917dd1e29a.png" class="" title="image-20220325101051170.png"> </li>
<li>说明 <ul>
<li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li>
<li>for循环和while循环可以相互转换</li>
</ul>
</li>
</ul>
</li>
<li>do-while循环 <ul>
<li><img src="/post/8df0ec14/1668174790101-1ce546e5-18a2-46ea-bfb0-0fc4aa432ca6.png" class="" title="image-20220325101054237.png"></li>
</ul>
</li>
<li>嵌套循环(多重循环) <ul>
<li>将一个循环放在另一个循环体内，就形成了嵌套循环。其中， for ,while ,do…while均可以作为外层循环或内层循环。</li>
<li>实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的 循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开 始下一次的循环。</li>
<li>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次。</li>
</ul>
</li>
</ul>
<h6 id="特殊关键字的使用：-break、continue"><a href="#特殊关键字的使用：-break、continue" class="headerlink" title="特殊关键字的使用： break、continue"></a>特殊关键字的使用： break、continue</h6><ul>
<li>break 语句 <ul>
<li> break语句用于终止某个循环语句块的执行 </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; ……</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li> break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是 哪一层语句块 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">label1: &#123; ……</span><br><span class="line">label2: 	&#123; ……</span><br><span class="line">label3: 		&#123; ……</span><br><span class="line">				<span class="keyword">break</span> label2;</span><br><span class="line">				……</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>continue <ul>
<li>continue只能使用在循环结构中</li>
<li>continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环</li>
<li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</li>
</ul>
</li>
<li>另外： <ul>
<li>return：并非专门用于结束循环的，它的功能是结束一个方法。 当一个方法执行到一个return语句时，这个方法将被结束。</li>
<li>与break和continue不同的是，return直接结束整个方法，不管 这个return处于多少层循环之内</li>
</ul>
</li>
</ul>
<h6 id="特殊流程控制语句说明"><a href="#特殊流程控制语句说明" class="headerlink" title="特殊流程控制语句说明"></a>特殊流程控制语句说明</h6><ul>
<li>break只能用于switch语句和循环语句中。</li>
<li>continue 只能用于循环语句中。</li>
<li>二者功能类似，但continue是终止本次循环，break是终止本层循环。</li>
<li>break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。</li>
<li>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</li>
<li>很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条 语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同 于goto的。（特别不建议使用goto）</li>
</ul>
<h1 id="第三章、数组"><a href="#第三章、数组" class="headerlink" title="第三章、数组"></a>第三章、数组</h1><h2 id="3-1-概述："><a href="#3-1-概述：" class="headerlink" title="3.1   概述："></a>3.1   概述：</h2><blockquote>
<p>数组(Array)，是多个相同类型数据按一定顺序排列 的集合，并使用一个名字命名，并通过编号的方式 对这些数据进行统一管理。</p>
</blockquote>
<ul>
<li>数组的常见概念： <ul>
<li> 数组名 </li>
<li> 下标(或索引) </li>
<li> 元素 </li>
<li> 数组的长度 </li>
</ul>
</li>
<li> 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括 基本数据类型和引用数据类型。 </li>
<li> 创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是 这块连续空间的首地址。 </li>
<li> 数组的长度一旦确定，就不能修改。 </li>
<li> 我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。 </li>
<li>数组的分类： <ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对 象数组)</li>
</ul>
</li>
</ul>
<h2 id="3-2-一维数组"><a href="#3-2-一维数组" class="headerlink" title="3.2  一维数组"></a>3.2  一维数组</h2><ul>
<li><h2 id="一维数组的声明方式："><a href="#一维数组的声明方式：" class="headerlink" title="一维数组的声明方式： "></a>一维数组的声明方式： </h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="keyword">var</span>[] 或 type[] <span class="keyword">var</span>；</span><br></pre></td></tr></table></figure>


<ul>
<li>Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; //非法<br> 需要再初始化时再定义数组长度； </li>
<li> 初始化： </li>
<li> <img src="/post/8df0ec14/1668175004265-4cfae7db-deb8-4c9d-8dea-e7a3e1eb76d1.png" class="" title="image-20220325101100211.png"> </li>
<li> 一维数组的使用： </li>
<li> 定义并用运算符new为之分配空间后，才可以引用数组中的每个元素； </li>
<li>数组元素的引用方式：数组名[数组元素下标] <ul>
<li>数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];</li>
<li>数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]=new  int[3]; 可引用的数组元素为a[0]、a[1]、a[2]</li>
</ul>
</li>
<li> 每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长 度(元素个数) </li>
<li> 数组一旦初始化，其长度是不可变的 </li>
<li><h2 id="数组是引用类型，它的元素相当于类的成员变量，因此数组一经-分配空间，其中的每个元素也被按照成员变量同样的方式被隐式-初始化。例如："><a href="#数组是引用类型，它的元素相当于类的成员变量，因此数组一经-分配空间，其中的每个元素也被按照成员变量同样的方式被隐式-初始化。例如：" class="headerlink" title="数组是引用类型，它的元素相当于类的成员变量，因此数组一经 分配空间，其中的每个元素也被按照成员变量同样的方式被隐式 初始化。例如： "></a>数组是引用类型，它的元素相当于类的成员变量，因此数组一经 分配空间，其中的每个元素也被按照成员变量同样的方式被隐式 初始化。例如： </h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123;</span><br><span class="line"><span class="type">int</span> a[]= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">System.out.println(a[<span class="number">3</span>]); <span class="comment">//a[3]的默认值为0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li> 对于基本数据类型而言，默认初始化值各有不同 </li>
<li> 对于引用数据类型而言，默认初始化值为null(注意与0不同！) </li>
<li> <img src="/post/8df0ec14/1668175023196-a71040ea-3048-4888-b934-b2621daf49b4.png" class="" title="image-20220325101103390.png"> </li>
</ul>
<h2 id="3-3-多维数组"><a href="#3-3-多维数组" class="headerlink" title="3.3  多维数组"></a>3.3  多维数组</h2><h2 id="3-4-数组中设计的常见算法"><a href="#3-4-数组中设计的常见算法" class="headerlink" title="3.4 数组中设计的常见算法"></a>3.4 数组中设计的常见算法</h2><ol>
<li> 数组元素的赋值(杨辉三角、回形数等) </li>
<li> 求数值型数组中元素的最大值、最小值、平均数、总和等 </li>
<li> 数组的复制、反转、查找(线性查找、二分法查找) </li>
<li> 数组元素的排序算法 </li>
</ol>
<h3 id="二分查找算法演示"><a href="#二分查找算法演示" class="headerlink" title="二分查找算法演示"></a>二分查找算法演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分法查找：要求此数组必须是有序的。</span></span><br><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">99</span>,-<span class="number">54</span>,-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">43</span>,<span class="number">256</span>,<span class="number">999</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line"><span class="comment">//int number = 25;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//首索引位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr3.length - <span class="number">1</span>;<span class="comment">//尾索引位置</span></span><br><span class="line"><span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (head + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr3[middle] == number)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到指定的元素，索引为：&quot;</span> + middle);</span><br><span class="line">        isFlag = <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">break</span>;	</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr3[middle] &gt; number)&#123;</span><br><span class="line">        end = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//arr3[middle] &lt; number</span></span><br><span class="line">        head = middle + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;未找打指定的元素&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><blockquote>
<p>排序的目的是快速查找。</p>
</blockquote>
<ul>
<li>衡量排序算法的优劣： <ol>
<li><strong>时间复杂度</strong>：分析关键字的比较次数和记录的移动次数</li>
<li><strong>空间复杂度</strong>：分析排序算法中需要多少辅助内存</li>
<li><strong>稳定性</strong>：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保 持不变，则称这种排序算法是稳定的。</li>
</ol>
</li>
<li>排序算法分类：内部排序和外部排序。 <ul>
<li><strong>内部排序</strong>：整个排序过程不需要借助于外部存储器（如磁盘等），所有排 序操作都在内存中完成。</li>
<li><strong>外部排序</strong>：参与排序的数据非常多，数据量非常大，计算机无法把整个排 序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最 常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。</li>
</ul>
</li>
</ul>
<h4 id="★十大内部排序算法（详细在数据结构中学习）"><a href="#★十大内部排序算法（详细在数据结构中学习）" class="headerlink" title="★十大内部排序算法（详细在数据结构中学习）"></a>★十大内部排序算法（详细在数据结构中学习）</h4><ul>
<li>选择排序 <ul>
<li>直接选择排序、堆排序</li>
</ul>
</li>
<li>交换排序 <ul>
<li>冒泡排序、快速排序</li>
</ul>
</li>
<li>插入排序 <ul>
<li>直接插入排序、折半插入排序、Shell排序</li>
</ul>
</li>
<li> 归并排序 </li>
<li> 桶式排序 </li>
<li> 基数排序 </li>
<li> <img src="/post/8df0ec14/1668175061759-3ed1f37b-254d-4619-ad63-42ccb59f16de.png" class="" title="image-20220325101108662.png"> </li>
<li>各种内部排序方法性能比较 <ul>
<li><ol>
<li>从<strong>平均时间</strong>而言：快速排序最佳。但在最坏情况下时间性能不如堆排序和归 并排序。</li>
<li>从<strong>算法简单性</strong>看：由于直接选择排序、直接插入排序和冒泡排序的算法比较 简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序 算法，其算法比较复杂，认为是复杂排序。</li>
<li>从<strong>稳定性</strong>看：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排 序、快速排序、 Shell排序和堆排序是不稳定排序</li>
<li>从待排序的记录<strong>数n的大小</strong>看，n较小时，宜采用简单排序；而n较大时宜采 用改进排序。</li>
</ol>
</li>
</ul>
</li>
<li>排序算法的选择 <ul>
<li><ol>
<li>若n较小(如n≤50)，可采用直接插入或直接选择排序。 当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直 接插入，应选直接选择排序为宜。</li>
<li>若文件初始状态基本有序(指正序)，则应选用直接插入、冒泡或随机的快速排 序为宜；</li>
<li>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或 归并排序。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-Arrays工具类-使用"><a href="#3-5-Arrays工具类-使用" class="headerlink" title="3.5  Arrays工具类 使用"></a>3.5  Arrays工具类 使用</h2><ul>
<li>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比 如排序和搜索）的各种方法。</li>
<li><img src="/post/8df0ec14/1668175070735-8fbf988a-2a39-484a-837c-e02f3dfa2eb9.png" class="" title="image-20220325101111871.png"></li>
</ul>
<h2 id="3-6-数组使用中的常见异常"><a href="#3-6-数组使用中的常见异常" class="headerlink" title="3.6 数组使用中的常见异常"></a>3.6 数组使用中的常见异常</h2><blockquote>
<p>此处的异常在编译时并没有报错！！</p>
</blockquote>
<h4 id="数组脚标越界异常-ArrayIndexOutOfBoundsException"><a href="#数组脚标越界异常-ArrayIndexOutOfBoundsException" class="headerlink" title="数组脚标越界异常(ArrayIndexOutOfBoundsException)"></a>数组脚标越界异常(ArrayIndexOutOfBoundsException)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">System.out.println(arr[-<span class="number">1</span>]);</span><br><span class="line">访问到了数组中的不存在的脚标时发生。</span><br></pre></td></tr></table></figure>

<h4 id="空指针异常-NullPointerException"><a href="#空指针异常-NullPointerException" class="headerlink" title="空指针异常(NullPointerException)"></a>空指针异常(NullPointerException)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">arr引用没有指向实体，却在操作实体中的元素时。</span><br></pre></td></tr></table></figure>

<h1 id="第四章、面向对象"><a href="#第四章、面向对象" class="headerlink" title="第四章、面向对象"></a>第四章、面向对象</h1><h2 id="4-1、-面向过程与面向对象"><a href="#4-1、-面向过程与面向对象" class="headerlink" title="4.1、 面向过程与面向对象"></a>4.1、 面向过程与面向对象</h2><ul>
<li>面向过程(POP) 与 面向对象(OOP) <ul>
<li>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对 象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如 抽象、分类、继承、聚合、多态等。</li>
<li>简单解释： <ul>
<li>面向过程就是操作过程</li>
<li>面向对象就是操作过程里的逻辑实现</li>
</ul>
</li>
</ul>
</li>
<li>面向对象的三大特征 <ul>
<li>封装 (Encapsulation)</li>
<li>继承 (Inheritance)</li>
<li>多态 (Polymorphism)</li>
</ul>
</li>
<li>面向对象的思想概述 <ul>
<li>程序员从面向过程的<strong>执行者</strong>转化成了面向对象的<strong>指挥者</strong></li>
<li>面向对象分析方法分析问题的思路和步骤：</li>
<li>根据问题需要，选择问题所针对的现实世界中的实体。</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序 语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。</li>
</ul>
</li>
</ul>
<h2 id="4-2、类和对象"><a href="#4-2、类和对象" class="headerlink" title="4.2、类和对象"></a>4.2、类和对象</h2><ul>
<li>概述： <ul>
<li>类(Class)和对象(Object)是面向对象的核心概念。 <ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
</li>
<li>“万事万物皆对象</li>
</ul>
</li>
</ul>
<h3 id="Java类及类的成员"><a href="#Java类及类的成员" class="headerlink" title="Java类及类的成员"></a>Java类及类的成员</h3><ul>
<li> 属 性：对应类中的成员变量 </li>
<li> 行 为：对应类中的成员方法 </li>
<li> <img src="/post/8df0ec14/1668175150066-3268c367-79ed-4c3a-bf2b-d65de381cf3c.png" class="" title="image-20220325101115821.png"> </li>
<li>创建Java自定义类步骤： <ul>
<li><ol>
<li>定义类（考虑修饰符、类名）</li>
<li>编写类的属性（考虑修饰符、属性类型、属性名、初始化值）</li>
<li>编写类的方法（考虑修饰符、返回值类型、方法名、形参等）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-3、对象的创建和使用"><a href="#4-3、对象的创建和使用" class="headerlink" title="4.3、对象的创建和使用"></a>4.3、对象的创建和使用</h2><ul>
<li> 创建对象语法： <strong>类名 对象名 = new 类名();</strong> </li>
<li> 使用：“对象名.对象成员”的方式访问对象成员（包括属性和方法） </li>
<li> <img src="/post/8df0ec14/1668175159760-8c2e1428-d125-49ac-97c7-2459f8f61ba0.png" class="" title="image-20220325101118925.png"></li>
<li>注意： <ul>
<li>类的访问机制： <ul>
<li>在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。 （例外：static方法访问非static，编译不通过。）</li>
<li>在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中 定义的成员。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象的创建和使用：内存解析"><a href="#对象的创建和使用：内存解析" class="headerlink" title="对象的创建和使用：内存解析"></a>对象的创建和使用：内存解析</h3><ul>
<li> <img src="/post/8df0ec14/1668175167642-3be17d9a-924c-4347-bb52-b2e1c603dcfe.png" class="" title="image-20220325101121767.png"> </li>
<li>匿名对象 <ul>
<li>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这 样的对象叫做匿名对象。 <ul>
<li>如：new Person().shout();</li>
</ul>
</li>
<li>使用情况 <ul>
<li>如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</li>
<li>我们经常将匿名对象作为实参传递给一个方法调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-4、-类的成员之一：属性"><a href="#4-4、-类的成员之一：属性" class="headerlink" title="4.4、 类的成员之一：属性"></a>4.4、 类的成员之一：属性</h2><ul>
<li><p>概述：</p>
<p>  <img src="https://cdn.nlark.com/yuque/0/2022/png/26739307/1668175177812-db4f6f61-5869-4560-8d66-4b3f550b2862.png#averageHue=%23fcf7f6&clientId=u3a9e0fb5-c6a7-4&from=paste&height=371&id=u50b646b9&name=image-20220315101931459.png&originHeight=464&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104376&status=done&style=none&taskId=uf5046525-7a38-408d-8b05-d7f9b75d7ba&title=&width=516.8" alt="image-20220315101931459.png"></p>
</li>
<li><p>变量的分类：成员变量与局部变量 </p>
<ul>
<li> 在方法体外，类体内声明的变量称为成员变量。 </li>
<li> 在方法体内部声明的变量称为局部变量。 </li>
<li>注意：二者在初始化值方面的异同: <ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，均需显式初始化。</li>
</ul>
</li>
<li> 表格解释：  </li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>声明的位置</td>
<td>直接声明在类中</td>
<td>方法形参或内部、代码块内、构造器内等</td>
</tr>
<tr>
<td>修饰符</td>
<td>private、public、static、final等</td>
<td>不能用权限修饰符修饰，可以用final修饰</td>
</tr>
<tr>
<td>初始化值</td>
<td>堆空间 或 静态域内</td>
<td>没有默认初始化值，必须显式赋值，方可使用</td>
</tr>
<tr>
<td>内存加载位置</td>
<td>堆空间 或 静态域内</td>
<td>栈空间</td>
</tr>
</tbody></table>
<pre><code>  - 简单表述：大的有妆（修饰）且有自己的小金库（默认值），小的没有状，也没有小金库，要介绍自己（值），活动空间只有客栈（栈）
</code></pre>
<ul>
<li>对象属性的默认初始化赋值 <ul>
<li>当一个对象被创建时，会对其中各种类型的<strong>成员变量</strong>自动进行初始化赋值。除了 基本数据类型之外的变量类型都是引用类型，如上面的Person及前面讲过的数组。 <ul>
<li><img src="/post/8df0ec14/1668175186582-6d48981d-3cca-4b38-99f2-3d508203febd.png" class="" title="image-20220315101931459.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-5、类的成员之二：-方法-method"><a href="#4-5、类的成员之二：-方法-method" class="headerlink" title="4.5、类的成员之二： 方法(method)"></a>4.5、类的成员之二： 方法(method)</h2><p>概述：</p>
<ul>
<li>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中 也称为函数或过程。</li>
<li>将功能封装为方法的目的是，可以实现代码重用，简化代码</li>
<li>Java里的方法不能独立存在，所有的方法必须定义在类里。</li>
</ul>
<p>格式：</p>
<ul>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参<span class="number">1</span>, 参数类型 形参<span class="number">2</span>, …）｛ 方法体程序代码</span><br><span class="line"> <span class="keyword">return</span> 返回值; </span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>其中：<br>    修饰符：public,缺省,private, protected等<br>    返回值类型： </p>
<ul>
<li> 没有返回值：void。 </li>
<li> 有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用 方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” 形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开 返回值：方法在执行完毕后返还给调用它的程序的数据。 </li>
<li> 表格解释：  </li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>无返回值</th>
<th>有返回值</th>
</tr>
</thead>
<tbody><tr>
<td>无形参</td>
<td>返回值的类型 方法名（形参列表）{}</td>
<td>返回值的类型 方法名（）{}</td>
</tr>
<tr>
<td>有形参</td>
<td>void 方法名（形参列表）{}</td>
<td>返回值的类型 方法名（形参列表）{}</td>
</tr>
</tbody></table>
<ul>
<li><pre><code> 方法的调用     - 方法通过方法名被调用，且只有被调用才会执行。
</code></pre>
</li>
<li><pre><code> 注 意：     - 注 意：       - 方法被调用一次，就会执行一次      - 没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可 以不必使用return语句。如果使用，仅用来结束方法。      - 定义方法时，方法的结果应该返回给调用者，交由调用者处理。      - 方法中只能调用方法或属性，不可以在方法内部定义方法。
</code></pre>
</li>
</ul>
<h2 id="4-6、方法深入解析"><a href="#4-6、方法深入解析" class="headerlink" title="4.6、方法深入解析"></a>4.6、方法深入解析</h2><ul>
<li>方法的重载</li>
<li>可变形参的方法</li>
<li>方法参数的值传递机制</li>
<li>递归方法</li>
</ul>
<h3 id="再谈方法1：方法的重载-overload"><a href="#再谈方法1：方法的重载-overload" class="headerlink" title="再谈方法1：方法的重载(overload)"></a>再谈方法1：方法的重载(overload)</h3><ul>
<li>重载的概念 <ul>
<li>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。</li>
</ul>
</li>
<li>重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类 型)。调用时，根据方法参数列表的不同来区别。</li>
<li>重载示例：</li>
<li>//返回两个整数的和 int add(int x,int y){return x+y;}</li>
<li>//返回三个整数的和 int add(int x,int y,int z){return x+y+z;} //返回两个小数的和 double add(double x,double y){return x+y;}</li>
</ul>
<h3 id="再谈方法2：可变个数的形参"><a href="#再谈方法2：可变个数的形参" class="headerlink" title="再谈方法2：可变个数的形参"></a>再谈方法2：可变个数的形参</h3><p>概述：</p>
<ul>
<li><ol>
<li>声明格式：方法名(参数的类型名 …参数名)</li>
<li>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</li>
<li>可变个数形参的方法与同名的方法之间，彼此构成重载</li>
<li>可变参数方法的使用与方法参数部分使用数组是一致的</li>
<li>方法的参数部分有可变形参，需要放在形参声明的最后</li>
<li>在一个方法的形参位置，最多只能声明一个可变个数形参</li>
</ol>
</li>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String[] msg)</span>&#123;</span><br><span class="line">System.out.println(“含字符串数组参数的test方法 <span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">public void test1(String book)&#123;</span></span><br><span class="line"><span class="string">System.out.println(“****与可变形参方法构成重载的test1方法****&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(String ... books)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;****形参长度可变的test1方法****&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">TestOverload</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestOverload</span>();</span><br><span class="line"><span class="comment">//下面两次调用将执行第二个test方法</span></span><br><span class="line">to.test1();</span><br><span class="line">to.test1(<span class="string">&quot;aa&quot;</span> , <span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//下面将执行第一个test方法</span></span><br><span class="line">to.test(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="★方法参数的值传递机制"><a href="#★方法参数的值传递机制" class="headerlink" title="★方法参数的值传递机制"></a>★方法参数的值传递机制</h3><ul>
<li>方法，必须由其所在类或对象调用才有意义。若方法含有参数： <ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传给形参的参数值</li>
</ul>
</li>
<li>Java的实参值如何传入方法呢？ <ul>
<li>Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本 （复制品）传入方法内，而参数本身不受影响。 <ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</li>
<li>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</li>
</ul>
</li>
<li>图解： <ul>
<li><img src="/post/8df0ec14/1668175202613-007b5a9c-3086-4ac6-a2c4-09812acc1199.png" class="" title="image-20220325101148568.png"></li>
<li><img src="/post/8df0ec14/1668175208937-d1d21c4e-532f-4d13-a2a2-6c10ad1b4464.png" class="" title="image-20220325101151544.png"></li>
<li><img src="/post/8df0ec14/1668175219693-da7948e3-f44e-4324-90b4-de53baf58337.png" class="" title="image-20220325101154256.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><ul>
<li> 递归方法：一个方法体内调用它自身。 </li>
<li> 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执 行无须循环控制。 </li>
<li> 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死 循环。 </li>
<li> 双重递归 </li>
</ul>
<h2 id="4-7、-面向对象特征之一：-封装与隐藏"><a href="#4-7、-面向对象特征之一：-封装与隐藏" class="headerlink" title="4.7、 面向对象特征之一： 封装与隐藏"></a>4.7、 面向对象特征之一： 封装与隐藏</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><ul>
<li>我们程序设计追求“高内聚，低耦合”。 <ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。</li>
</ul>
</li>
<li> 隐藏对象<strong>内部的复杂性</strong>，只对外公开简单的接口。便于外界调用，从而提 高系统的<strong>可扩展性</strong>、<strong>可维护性</strong>。通俗的说，把该隐藏的隐藏起来，该暴露 的暴露出来。这就是封装性的设计思想。 </li>
<li> 注：使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或安全性问题。 </li>
</ul>
<h3 id="信息的封装和隐藏"><a href="#信息的封装和隐藏" class="headerlink" title="信息的封装和隐藏"></a>信息的封装和隐藏</h3><ul>
<li>Java中通过将数据声明为私有的(private)，再提供公共的（public） 方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的： <ul>
<li> <strong>隐藏</strong>一个类中不需要对外提供的实现细节； </li>
<li> 使用者只能通过事先定制好的<strong>方法来访问数据</strong>，可以方便地加入控制逻辑， 限制对属性的不合理操作； </li>
<li> 便于修改，增强代码的可维护性； </li>
<li> 代码解释 </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> legs;<span class="comment">// 将属性legs定义为private，只能被Animal类内部访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLegs</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="comment">// 在这里定义方法 eat() 和 move()</span></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != <span class="number">2</span> &amp;&amp; i != <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Wrong number of legs!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        legs = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLegs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> legs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">xb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        xb.setLegs(<span class="number">4</span>); <span class="comment">// xb.setLegs(-1000);</span></span><br><span class="line"><span class="comment">//xb.legs = -1000; // 非法</span></span><br><span class="line">        System.out.println(xb.getLegs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><h2 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符 "></a>四种访问权限修饰符 </h2></li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>（缺省）</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<ul>
<li>对于class的权限修饰只可以用public和default(缺省)。 <ul>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。</li>
</ul>
</li>
</ul>
<h3 id="类的成员之三：-构造器-或构造方法"><a href="#类的成员之三：-构造器-或构造方法" class="headerlink" title="类的成员之三： 构造器(或构造方法)"></a>类的成员之三： 构造器(或构造方法)</h3><h4 id="构造器的特征"><a href="#构造器的特征" class="headerlink" title="构造器的特征"></a>构造器的特征</h4><ul>
<li> 它具有与类相同的名称 </li>
<li> 它不声明返回值类型。（与声明为void不同） </li>
<li> 不能被static、final、synchronized、abstract、native修饰，不能有 return语句返回值 </li>
<li>构造器的作用：创建对象；给对象进行初始化 <ul>
<li> 如：Order o = new Order(); Person p = new Person(“Peter”,15); </li>
<li></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> legs;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        legs = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLegs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        legs = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLegs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> legs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>根据参数不同，构造器可以分为如下两类： <ul>
<li>隐式无参构造器（系统默认提供）</li>
<li>显式定义一个或多个构造器（无参、有参）</li>
</ul>
</li>
<li>注 意： <ul>
<li>Java语言中，每个类都至少有一个构造器</li>
<li>默认构造器的修饰符与所属类的修饰符一致</li>
<li>一旦显式定义了构造器，则系统不再提供默认构造器</li>
<li>一个类可以创建多个重载的构造器</li>
<li>父类的构造器不可被子类继承</li>
</ul>
</li>
</ul>
<h4 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h4><ul>
<li> 构造器一般用来创建对象的同时初始化对象。如 </li>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n , <span class="type">int</span> a)</span>&#123; name=n; age=a;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li> 构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。 </li>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, Date d)</span> &#123;<span class="built_in">this</span>(name,age);…&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;…&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Date d)</span> &#123;…&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li> 构造器重载，参数列表必须不同 </li>
</ul>
<h4 id="总结：属性赋值过程"><a href="#总结：属性赋值过程" class="headerlink" title="总结：属性赋值过程"></a>总结：属性赋值过程</h4><ul>
<li>赋值的位置： <ul>
<li><ol>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器中初始化</li>
<li>通过“对象.属性“或“对象.方法”的方式赋值</li>
</ol>
</li>
<li> 赋值的先后顺序： ① - ② - ③ - ④</li>
</ul>
</li>
</ul>
<h4 id="拓展知识：JavaBean"><a href="#拓展知识：JavaBean" class="headerlink" title="拓展知识：JavaBean"></a>拓展知识：JavaBean</h4><ul>
<li>JavaBean是一种Java语言写成的可重用组件。</li>
<li>所谓javaBean，是指符合如下标准的Java类： <ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
</li>
<li>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以 用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP 页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用 户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关 心任何改变。</li>
</ul>
<h4 id="拓展知识：UML类图"><a href="#拓展知识：UML类图" class="headerlink" title="拓展知识：UML类图"></a>拓展知识：UML类图</h4><img src="/post/8df0ec14/1668175252535-11835a9e-3d8a-475e-a16d-43b85394de22.png" class="" title="image-20220325101200993.png">

<h3 id="9-关键字：this的使用"><a href="#9-关键字：this的使用" class="headerlink" title="9.关键字：this的使用"></a>9.关键字：this的使用</h3><ul>
<li>在Java中，this关键字比较难理解，它的作用和其词义很接近。 <ul>
<li>它在方法内部使用，即这个方法所属对象的引用；</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。  this 可以调用类的属性、方法和构造器</li>
</ul>
</li>
<li>什么时候使用this关键字呢？ <ul>
<li> 当在方法内需要用到调用该方法的对象时，就用this。 </li>
<li> 具体的：我们可以用this来区分<strong>属性</strong>和局部变量。 </li>
<li> 比如：<strong>this.name</strong> = name； </li>
<li><ol>
<li>在任意方法或构造器内，如 果使用当前类的成员变量或成 员方法可以在其前面添加this， 增强程序的阅读性。不过，通 常我们都习惯省略this。</li>
<li>当形参与成员变量同名时， 如果在方法内或构造器内需要 使用成员变量，必须添加this来 表明该变量是类的成员变量</li>
<li>使用this访问属性和方法时， 如果在本类中未找到，会从父 类中查找</li>
</ol>
</li>
</ul>
</li>
<li>注意： <ul>
<li>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其 他的构造器！</li>
<li>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</li>
<li>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了 “this(形参列表)”</li>
<li>“this(形参列表)”必须声明在类的构造器的首行！</li>
<li>在类的一个构造器中，最多只能声明一个”this(形参列表)”</li>
</ul>
</li>
</ul>
<h3 id="10-关键字：package、-import的使用"><a href="#10-关键字：package、-import的使用" class="headerlink" title="10.关键字：package、 import的使用"></a>10.关键字：package、 import的使用</h3><ul>
<li>概述： <ul>
<li> package语句作为Java源文件的第一条语句，指明该文件中定义的类所在 的包。(若缺省该语句，则指定为无名包)。它的格式为： package 顶层包名.子包名 ; </li>
<li> 包对应于文件系统的目录，package语句中，用 “.” 来指明包(目录)的层次； </li>
<li> 包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx </li>
</ul>
</li>
<li>包的作用 <ul>
<li>包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</li>
<li>包可以包含类和子包，划分项目层次，便于管理</li>
<li>解决类命名冲突的问题</li>
<li>控制访问权限</li>
</ul>
</li>
</ul>
<h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h4><ul>
<li>概述 <ul>
<li>MVC是常用的设计模式之一，将整个程序分为三个层次：<strong>视图模型层</strong>，控制器层，与 <strong>数据模型层</strong>。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式 使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程 序的耦合性。</li>
<li><img src="/post/8df0ec14/1668175273223-3cf94eeb-310c-4561-a2cb-66da43c9e3b8.png" class="" title="image-20220325101206283.png"></li>
<li><img src="/post/8df0ec14/1668175278788-f4d226da-c3e3-4f2c-bf4e-7eb690b1f4fd.png" class="" title="image-20220325101208882.png"></li>
</ul>
</li>
<li>JDK中主要的包介绍 <ul>
<li><ol>
<li>java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System和 Thread，提供常用功能</li>
<li>java.net—-包含执行与网络相关的操作的类和接口。</li>
<li>java.io —-包含能提供多种输入/输出功能的类。</li>
<li>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日 期日历相关的函数。</li>
<li>java.text—-包含了一些java格式化相关的类</li>
<li>java.sql—-包含了java进行JDBC数据库编程的相关类/接口</li>
<li>java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这 些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S</li>
</ol>
</li>
</ul>
</li>
<li>注意： <ul>
<li><ol>
<li>在源文件中使用import显式的导入指定包下的类或接口</li>
<li>声明在包的声明和类的声明之间。</li>
<li>如果需要导入多个类或接口，那么就并列显式多个import语句即可</li>
<li>举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</li>
<li>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的 是哪个类。</li>
<li>如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。</li>
<li>import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-8、面向对象特征之二：-继承性"><a href="#4-8、面向对象特征之二：-继承性" class="headerlink" title="4.8、面向对象特征之二： 继承性"></a>4.8、面向对象特征之二： 继承性</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><blockquote>
<p>子类继承父类，会获得所有的父类的属性方法，都是有些会被权限限制，比如父类私有的不能直接调（用get方法调用），也无法修改，<br>##二、关键字 ：extends<br>##三、代码介绍：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> Date birthDate;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> String school;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Student类继承了父类Person的所有属性和方法，并增加了一<br>个属性school。Person中的属性和方法,Student都可以使用。</li>
</ul>
<h5 id="继承性作用"><a href="#继承性作用" class="headerlink" title="继承性作用:"></a>继承性作用:</h5><ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。</li>
<li>继承的出现，更有利于功能的扩展。</li>
<li>继承的出现让类与类之间产生了关系，提供了多态的前提。</li>
</ul>
<h5 id="继承性规则"><a href="#继承性规则" class="headerlink" title="继承性规则"></a>继承性规则</h5><ul>
<li> 子类不能直接访问父类中私有的(private)的成员变量和方法。 </li>
<li> Java只支持单继承和多层继承，不允许多重继承 </li>
<li> 一个子类只能有一个父类 </li>
<li> 一个父类可以派生出多个子类 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubDemo</span> <span class="keyword">extends</span> <span class="title class_">Demo</span>&#123; &#125; <span class="comment">//ok    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubDemo</span> <span class="keyword">extends</span> <span class="title class_">Demo1</span>,Demo2...<span class="comment">//error</span></span><br></pre></td></tr></table></figure>


<h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><blockquote>
<p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称<br>为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
</blockquote>
<h4 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h4><ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方的访问权限</li>
<li>子类不能重写父类中声明为private权限的方法</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ul>
<h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> String name;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\n&quot;</span> +<span class="string">&quot;age: &quot;</span>+ age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String school;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123; <span class="comment">//重写方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\nage: &quot;</span>+ age + <span class="string">&quot;\nschool: &quot;</span>+ school;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">	Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">	s1.name=<span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">	s1.age=<span class="number">20</span>;</span><br><span class="line">	s1.school=<span class="string">&quot;school2&quot;</span>;</span><br><span class="line">	System.out.println(s1.getInfo()); <span class="comment">//Name:Bob age:20 school:school2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关键字super"><a href="#2-关键字super" class="headerlink" title="2. 关键字super"></a>2. 关键字super</h3><p>作用</p>
<ul>
<li>super可用于访问父类中定义的属性</li>
<li>super可用于调用父类中定义的成员方法</li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
<blockquote>
<p>注意：<br>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员<br>super的追溯不仅限于直接父类<br>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</p>
</blockquote>
<table>
<thead>
<tr>
<th>No.</th>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>访问属性</td>
<td>访问属性 访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>直接访问父类中的属性</td>
</tr>
<tr>
<td>2</td>
<td>访问属性</td>
<td>调用方法 访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>3</td>
<td>访问属性</td>
<td>调用构造器 调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须放在子类构造器的首行</td>
</tr>
</tbody></table>
<h3 id="3-子类对象实例化过程"><a href="#3-子类对象实例化过程" class="headerlink" title="3.  子类对象实例化过程"></a>3.  子类对象实例化过程</h3><img src="/post/8df0ec14/1668175293192-45af8303-caaf-4464-823d-3d3db2c24667.png" class="" title="image-20220325101214686.png">

<h2 id="4-9、面向对象特征之三：多态性"><a href="#4-9、面向对象特征之三：多态性" class="headerlink" title="4.9、面向对象特征之三：多态性"></a>4.9、面向对象特征之三：多态性</h2><ul>
<li>多态性，是面向对象中最重要的概念，在Java中的体现： <ul>
<li>对象的多态性：父类的引用指向子类的对象</li>
<li>可以直接应用在抽象类和接口上</li>
</ul>
</li>
<li>Java引用变量有两个类型：<strong>编译时类型</strong>和<strong>运行时类型</strong>。编译时类型由声明<br> 该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：<strong>编译</strong>时，看<strong>左边</strong>；<strong>运行</strong>时，看<strong>右边</strong>。 <ul>
<li><strong>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</strong></li>
<li>*多态情况下，“看左边”：**看的是父类的引用（父类中不具备子类特有的方法） **</li>
<li>“看右边”：**看的是子类的对象（实际运行的是子类重写父类的方法）</li>
</ul>
</li>
<li>对象的多态 —在Java中,子类的对象可以替代父类的对象使用 <ul>
<li><img src="/post/8df0ec14/1668175316539-190d6ec7-1385-46c9-ae54-fcfed02fd5f8.png" class="" title="image-20220419141554104.png"></li>
</ul>
</li>
<li><strong>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能</strong>再访问子类中添加的属性和方法 <img src="/post/8df0ec14/1668175328098-8dd4e0ef-c097-4c1e-a907-dbd29cb0865d.png" class="" title="image-20220419141506715.png"> </li>
<li><strong>多态性应用举例</strong> <ul>
<li><strong>方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法</strong> <ul>
<li><img src="/post/8df0ec14/1668175336343-5abc480b-148f-432f-8fea-49eefee7e9c7.png" class="" title="image-20220419141554104.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>虚拟方法调用</strong>(Virtual Method Invocation) <ul>
<li><strong>正常的方法调用</strong> <ul>
<li><img src="/post/8df0ec14/1668175350119-1dc45967-7b9f-46e5-b605-90d2d288625b.png" class="" title="image-20220419141729834.png"></li>
</ul>
</li>
<li>虚拟方法调用（多态情况下） <ul>
<li><img src="/post/8df0ec14/1668175354470-6e4d940c-20e0-4850-8f2a-c6bcd8895140.png" class="" title="image-20220419141813960.png"></li>
</ul>
</li>
<li>编译时类型和运行时类型 <ul>
<li>编译时e未Person类型，二方法的调用是在运行时确定的，所以调用的是Student类的getinfo（）方法。 – <strong>动态绑定</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-9-1、方法的重载与重写对比"><a href="#4-9-1、方法的重载与重写对比" class="headerlink" title="4.9.1、方法的重载与重写对比"></a>4.9.1、方法的重载与重写对比</h3><ol>
<li>定义不同</li>
<li>从编译和运行的角度 <ol>
<li><img src="/post/8df0ec14/1668175411458-9d5ef152-8e6e-4c32-95d7-ee820045ed3f.png" class="" title="image-20220419142454060.png"></li>
</ol>
</li>
</ol>
<h3 id="4-9-2、多态小结"><a href="#4-9-2、多态小结" class="headerlink" title="4.9.2、多态小结"></a>4.9.2、多态小结</h3><ul>
<li>多态作用： <ul>
<li>提高了代码的通用性，常称为接口重用</li>
</ul>
</li>
<li>前提： <ul>
<li>需要存在继承或者实现关系</li>
<li>有方法的重写</li>
</ul>
</li>
<li>成员方法： <ul>
<li>编译时：要查看引用变量所声明的类中是否又所调用的方法。</li>
<li>运行时：调用实际new的对象所属的类中的重写方法。</li>
</ul>
</li>
<li>成员变量： <ul>
<li>不具备多态性，只看引用变量所声明的类</li>
</ul>
</li>
</ul>
<h3 id="4-9-3、instanceof操作符"><a href="#4-9-3、instanceof操作符" class="headerlink" title="4.9.3、instanceof操作符"></a>4.9.3、instanceof操作符</h3><ul>
<li>x instanceof A :检验x是否为类A的对象，返回值为boolean型</li>
<li>避免发生转换类型错误的异常 <ul>
<li><img src="/post/8df0ec14/1668175417557-e092be05-e682-4282-9390-6fc0d7f72ae6.png" class="" title="image-20220419150818865.png"></li>
</ul>
</li>
</ul>
<h3 id="4-9-4、对象类型转换（Casting）"><a href="#4-9-4、对象类型转换（Casting）" class="headerlink" title="4.9.4、对象类型转换（Casting）"></a>4.9.4、对象类型转换（Casting）</h3><ul>
<li>基本数据类型的Casting： <ul>
<li><img src="/post/8df0ec14/1668175444122-14571a58-e749-4745-bac2-ef249d603d41.png" class="" title="image-20220419151117822.png"></li>
</ul>
</li>
<li>对Java对象的强制类型转换称为造型 <ul>
<li> <img src="/post/8df0ec14/1668175423845-fea55f59-1f44-4fe3-a6d2-4bca4beda8df.png" class="" title="image-20220419151647305.png"> </li>
<li>举例： <ul>
<li><img src="/post/8df0ec14/1668175433422-31a5f5af-180d-4b9c-9ddf-d3a94bfd740d.png" class="" title="image-20220419151955778.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-10、Object类的使用"><a href="#4-10、Object类的使用" class="headerlink" title="4.10、Object类的使用"></a>4.10、Object类的使用</h2><ul>
<li>Object类是所有Java类的根父类</li>
<li>如果在类的声明中未使用extends关键字指明其父类,则默认父类 为iava.lang.Obiect类</li>
</ul>
<h3 id="4-10-1、主要结构"><a href="#4-10-1、主要结构" class="headerlink" title="4.10.1、主要结构"></a>4.10.1、主要结构</h3><pre><code>![image-20220419152500627.png](https://cdn.nlark.com/yuque/0/2022/png/26739307/1668175464234-da6ad50c-7b82-4514-9b25-f734056a0bb5.png#averageHue=%23c1d5eb&amp;clientId=u3a9e0fb5-c6a7-4&amp;from=paste&amp;height=279&amp;id=u4adaf346&amp;name=image-20220419152500627.png&amp;originHeight=349&amp;originWidth=853&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60780&amp;status=done&amp;style=none&amp;taskId=ucb50f504-3eaa-424c-91be-0fe1ff00701&amp;title=&amp;width=682.4)
</code></pre>
<h3 id="4-10-2、-操作符与equals方法"><a href="#4-10-2、-操作符与equals方法" class="headerlink" title="4.10.2、==操作符与equals方法"></a>4.10.2、==操作符与equals方法</h3><ul>
<li>==： <ul>
<li>基本类型比较值：只要两个变量的值相等，即为true</li>
<li>引用类型比较引用，指向用一个对象时，才返回true</li>
<li><img src="/post/8df0ec14/1668175472128-4ff0b3b4-7a8e-4327-81c3-045fc0f2df78.png" class="" title="image-20220419152846064.png"></li>
</ul>
</li>
<li>equals（）：所有类都继承了object，也就获得了equals（方法，还可以重写） <ul>
<li><img src="/post/8df0ec14/1668175476378-e96a83d5-e647-44e8-8dcc-4d1bb0505db2.png" class="" title="image-20220419160452014.png"></li>
<li>特例:当用equals()方法进行比较时,对类File、String、Date及包装类 (Wrapper Class)来说,是比较类型及内容而不考虑引用的是否是同一个对 <ul>
<li>原因:在这些类中重写了Object类的equals()方法。</li>
</ul>
</li>
<li>当自定义使用equals()时,可以重写。用于比较两个对象的“内容”是否都 相等</li>
</ul>
</li>
<li>重写equals（）方法的原则 <ul>
<li><img src="/post/8df0ec14/1668175485081-e06179bc-292a-4a56-abe6-c39a7224e045.png" class="" title="image-20220419160712557.png"></li>
<li>一般将已知的数据放在前面，防止出现空指针异常</li>
</ul>
</li>
<li> <strong>String、Date、File、包装类</strong>等都<strong>重写了Object的equals（）</strong>方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同 </li>
</ul>
<h3 id="4-10-3、-和equals的区别"><a href="#4-10-3、-和equals的区别" class="headerlink" title="4.10.3、==和equals的区别"></a>4.10.3、==和equals的区别</h3><ol>
<li><p>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值,对于引用类型 就是比较内存地址</p>
</li>
<li><p>equals的话,它是属于java.lang.Object类里面的方法,如果该方法没有被重写过默认也 是;我们可以看到String等类的equals方法是被重写过的,而且String类在日常开发中 用的比较多,久而久之,形成了equals是比较值的错误观点。</p>
</li>
<li><p>具体要看自定义类里有没有重写Object的equals方法来判断。</p>
</li>
<li><p>通常情况下,重写equals方法,会比较类中的相应属性是否都相等。</p>
<p>练习比较：                <img src="/post/8df0ec14/1668175501404-90879e24-0bee-476c-b39f-022ab0847d55.png" class="" title="image-20220419162229282.png"></p>
<img src="/post/8df0ec14/1668175506907-1516a1db-4cd7-4bc3-98c3-679d16b140a6.png" class="" title="image-20220419162818688.png"></li>
</ol>
<blockquote>
<p>上面m1 和 m2是不相同对象，即false</p>
</blockquote>
<h3 id="4-10-4、toString（）方法"><a href="#4-10-4、toString（）方法" class="headerlink" title="4.10.4、toString（）方法"></a>4.10.4、toString（）方法</h3><ul>
<li>toString()方法在Object类中定义,其返回值是String类型,返回类名和它 的引用地址。</li>
<li>在进行String与其它类型数据的连接操作时,自动调用toString()方法 <ul>
<li>Date now=new Date();</li>
<li>System.out.printin(“now=”+now);相当于</li>
<li>System.out.printin(“now=”+now.toString());</li>
</ul>
</li>
<li>可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法,返回字符串的值。 <ul>
<li>s1=”hello”;</li>
<li>System.out.println(s1);/相当于System.out.printin(s1.toString());</li>
</ul>
</li>
<li>基本类型数据转换为String类型时,调用了对应包装类的toString()方法 <ul>
<li>int a=10; System.out.println(“a=”+a);</li>
</ul>
</li>
</ul>
<h3 id="4-10-5、包装类的使用"><a href="#4-10-5、包装类的使用" class="headerlink" title="4.10.5、包装类的使用"></a>4.10.5、包装类的使用</h3><ul>
<li> 针对八种基本数据类型定义相对的引用类型–包装类（封装类） </li>
<li> 有了类的特点，就可以调用类中的方法，Java才是真正的面向对象 </li>
<li> <img src="/post/8df0ec14/1668175515227-4fba68f7-e3e6-4eab-80eb-d2c8496b04e6.png" class="" title="image-20220419164709440.png"> </li>
<li> <img src="/post/8df0ec14/1668175519484-1a48bc6c-c8ff-4a1b-a1e9-de84711a8827.png" class="" title="image-20220419164954523.png"> </li>
<li> <img src="/post/8df0ec14/1668175524510-7d68c004-cf00-4661-995d-aee547b5d7f8.png" class="" title="image-20220419165101349.png"> </li>
<li> 总结：基本类型、包装类与String类间的转换 </li>
<li> <img src="/post/8df0ec14/1668175530161-61a7c7c5-9d91-4b39-a69a-d2afd1ac97a6.png" class="" title="image-20220419165316056.png"> </li>
<li><h2 id="包装类用法举例"><a href="#包装类用法举例" class="headerlink" title="包装类用法举例 "></a>包装类用法举例 </h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">装箱:</span><br><span class="line">包装类使得一个基本数据类型的数据变成了类。</span><br><span class="line">有了类的特点, 可以调用类中的方法。</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> t.toString();<span class="comment">//s=&quot;500&quot;,t是类,有toString方法</span></span><br><span class="line"><span class="comment">// String s1=Integer.toString(314);//s1=&quot;314“将数字转换成字符串。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;4.56&quot;</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">ds</span> <span class="operator">=</span> Double.parseDouble(s2);<span class="comment">//将字符串转换成数字</span></span><br><span class="line"></span><br><span class="line">拆箱:</span><br><span class="line">将数字包装类中内容变为基本数据类型。</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t.intValue();<span class="comment">//j=500,intValue取出包装类中的数据 </span></span><br><span class="line">包装类在实际开发中用的最多的在于字符串变为基本数据类型。</span><br><span class="line">String str1=<span class="string">&quot;30&quot;</span>; </span><br><span class="line">String str2=<span class="string">&quot;30.3&quot;</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parselnt(str1);<span class="comment">//将字符串变为int型</span></span><br><span class="line">floatf=Float.parseFloat(str2);<span class="comment">//将字符串变为int型</span></span><br></pre></td></tr></table></figure>


<p>实例：<img src="/post/8df0ec14/1668175541346-167767eb-fc5b-4f88-8b5c-b1d11011ace9.png" class="" title="image-20220419170446572.png"></p>
<img src="/post/8df0ec14/1668175546773-373962af-c46b-4ce8-9777-fd83fe3c5ebc.png" class="" title="image-20220419170514425.png">

<ul>
<li><p>解析： </p>
<ul>
<li><p>1.0    Integer会提升类型</p>
</li>
<li><p>1       不会被影响</p>
</li>
<li></li>
<li><p>false   不同对象</p>
</li>
<li><p>true    一样的数值</p>
</li>
<li><p>false   超出int的氛围 ，就会new一个对象</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：boolean默认值为false，Boolean默认值为null；</p>
</blockquote>
<h3 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h3><h4 id="如何实现向下转型？需要注意什么问题？如何解决次问题？"><a href="#如何实现向下转型？需要注意什么问题？如何解决次问题？" class="headerlink" title="如何实现向下转型？需要注意什么问题？如何解决次问题？"></a>如何实现向下转型？需要注意什么问题？如何解决次问题？</h4><ul>
<li><h2 id="使用强转符"><a href="#使用强转符" class="headerlink" title="使用强转符 "></a>使用强转符 </h2></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Man();</span><br><span class="line"></span><br><span class="line">Man m = (Man)p;</span><br></pre></td></tr></table></figure>


<ul>
<li> 会出现ClassCastExcption异常 </li>
<li> 使用instanceof在进行向下转型前判断（避免出现上面的异常） </li>
</ul>
<h4 id="和-equals-有何区别"><a href="#和-equals-有何区别" class="headerlink" title="== 和 equals() 有何区别"></a>== 和 equals() 有何区别</h4><ul>
<li>== 对比的是基本数据类型，不同类型不能比较，并且会比较地址值</li>
<li>equals（）是一个方法，对比引用类型</li>
</ul>
<h4 id="自动拆箱、自动装箱"><a href="#自动拆箱、自动装箱" class="headerlink" title="自动拆箱、自动装箱"></a>自动拆箱、自动装箱</h4><p>Integer i = 10；</p>
<p>基本数据类型、包装类 ==&gt;  String：valueOf（Xxx xx;</p>
<p>String==&gt; 基本数据类型、包装类:parseXxx(String s)；</p>
<h2 id="4-11、关键字：static"><a href="#4-11、关键字：static" class="headerlink" title="4.11、关键字：static"></a>4.11、关键字：static</h2><ul>
<li>使用范围： <ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
</li>
<li>被修饰后的成员具备以下特点： <ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
</li>
<li>其他说明： <ul>
<li>静态变量随着类的加载而加载。可以通过“类.静态变量”的方式进行调用</li>
<li>因为类只会加载一次，所以静态对象只会加载一次，即存在一份，不会因为new对象而改变，存放在方法区的静态域中。</li>
</ul>
</li>
</ul>
<h3 id="4-11-1、修饰属性"><a href="#4-11-1、修饰属性" class="headerlink" title="4.11.1、修饰属性"></a>4.11.1、修饰属性</h3><ul>
<li>static：静态对象、类对象</li>
<li>静态变量：创建了类的多个对象，多个对象共享同一个静态变量。即通过某个对象修改时，会导致其他对象调用时，是修改过了的</li>
<li>实例变量（非静态变量）：创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性，修改其中一个非静态属性时，不会导致其他对象中同样的属性值的修改</li>
</ul>
<h3 id="4-11-2、修饰方法"><a href="#4-11-2、修饰方法" class="headerlink" title="4.11.2、修饰方法"></a>4.11.2、修饰方法</h3><ul>
<li> 没有对象的实例时，可以用**类名.方法名()**的形式访问由static修饰的类方法。 </li>
<li> <strong>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</strong> </li>
<li> 因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。 </li>
</ul>
<h3 id="4-11-3、如何确定是否需要声明为static"><a href="#4-11-3、如何确定是否需要声明为static" class="headerlink" title="4.11.3、如何确定是否需要声明为static"></a>4.11.3、如何确定是否需要声明为static</h3><ul>
<li>属性：需要共享（即只需要一个声明或者修改）的属性就可以声明为static</li>
<li>方法： <ul>
<li>操作静态属性的方法，通常设置为static</li>
<li>工具类的方法，习惯上声明为static，如Math、array</li>
</ul>
</li>
</ul>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul>
<li> <strong>设计模式</strong>是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路” </li>
<li> 简介：是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。 </li>
</ul>
<blockquote>
<p>就是一个类中只有一个对象，并且是静态对象，属性也是静态属性</p>
</blockquote>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> single; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>) &#123;</span><br><span class="line">        single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single; </span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者的区别：</p>
<ul>
<li>饿汉式：开始就提供加载对象 <ul>
<li>好处：线程安全</li>
<li>坏处：占用空间资源（不使用也会存在在方法区）</li>
</ul>
</li>
<li>懒汉式：在调用时才进行加载对象 <ul>
<li>好处：需要时才创建，节省空间</li>
<li>坏处：存在线程安全（多线程可修复）</li>
</ul>
</li>
</ul>
<h3 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h3><ul>
<li>由于单例模式只生成一个实例，<strong>减少了系统性能开销</strong>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>网站的计数器</strong>，一般也是单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li><strong>数据库连接池</strong>的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 </li>
<li>项目中，<strong>读取配置文件的类</strong>，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li><strong>Application 也是单例的典型应用</strong></li>
<li>Windows的**Task Manager (任务管理器)**就是很典型的单例模式</li>
<li>Windows的**Recycle Bin (回收站)**也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
</ul>
<h2 id="4-12、main方法的语法"><a href="#4-12、main方法的语法" class="headerlink" title="4.12、main方法的语法"></a>4.12、main方法的语法</h2><ul>
<li> 由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。 </li>
<li> 又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。 </li>
<li> <img src="/post/8df0ec14/1668175580932-4f98f70d-72ee-4483-b30d-098843eec06d.png" class="" title="image-20220421103912822.png"> </li>
</ul>
<h2 id="4-13、-类的成员之四：代码块"><a href="#4-13、-类的成员之四：代码块" class="headerlink" title="4.13、 类的成员之四：代码块"></a>4.13、 类的成员之四：代码块</h2><ul>
<li>代码块(或初始化块)的作用： <ul>
<li>对Java类或对象进行初始化</li>
</ul>
</li>
<li>代码块(或初始化块)的分类： <ul>
<li> 一个类中代码块若有修饰符，则只能被static修饰，称为<strong>静态代码块(static block)<strong>，没有使用static修饰的，为</strong>非静态代码块</strong>。 </li>
<li>静态代码块：用static 修饰的代码块 <ul>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。</li>
</ul>
</li>
<li>非静态代码块：没有static修饰的代码块 <ul>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>.除了调用非静态的结构外，还可以调用静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/post/8df0ec14/1668175587076-01d8db28-630e-47da-996b-cc62a92469c3.png" class="" title="image-20220421103912822.png">

<h2 id="4-14、关键字：final"><a href="#4-14、关键字：final" class="headerlink" title="4.14、关键字：final"></a>4.14、关键字：final</h2><ul>
<li> 在Java中声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。 </li>
<li><strong>final</strong>标记的类不能被继承。提高安全性，提高程序的可读性。 <ul>
<li>String类、System类、StringBuffer类</li>
</ul>
</li>
<li><strong>final</strong>标记的方法不能被子类重写。 <ul>
<li>比如：Object类中的getClass()。</li>
</ul>
</li>
<li><strong>final</strong>标记的变量(<strong>成员变量或局部变量)即称为常量。</strong>名称大写，且只能被赋值一次。 <ul>
<li> final标记的成员变量<strong>必须</strong>在声明时或在每个构造器中或代码块中<strong>显式赋值</strong>，然后才能使用。 </li>
<li> final double MY_PI = 3.14; </li>
</ul>
</li>
<li> final修饰形参时，表明形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦调用以后，就只能在方法体内使用此形参，但不能进行重新赋值 </li>
</ul>
<img src="/post/8df0ec14/1668175593422-c3f78f33-bb87-424b-9d93-0b5141d726da.png" class="" title="image-20220426142634790.png">

<img src="/post/8df0ec14/1668175600284-fa039967-ff1c-40f1-9081-731d56015a33.png" class="" title="image-20220426142651357.png">

<img src="/post/8df0ec14/1668175604945-4a77b000-2c80-4a72-a58a-d8312d1e3b78.png" class="" title="image-20220426142701309.png">

<ul>
<li>final 用来修饰变量，此时的“变量”就称为一个常量</li>
</ul>
<p>运用举例</p>
<img src="/post/8df0ec14/1668175614315-4aadf208-fccd-4321-bbe0-862769bff4e7.png" class="" title="image-20220426143859678.png">

<img src="/post/8df0ec14/1668175618654-29c9dc92-f8fe-4017-923a-3403244f3399.png" class="" title="image-20220426144215166.png">

<h2 id="4-15、抽象类与抽象方法"><a href="#4-15、抽象类与抽象方法" class="headerlink" title="4.15、抽象类与抽象方法"></a>4.15、抽象类与抽象方法</h2><p>即为父类说明抽象方法，子类实现抽象方法</p>
<ul>
<li> 用abstract关键字来修饰一个类，这个类叫做抽象类。 </li>
<li> 用abstract来修饰一个方法，该方法叫做抽象方法。 </li>
<li> 抽象方法：只有方法的声明，没有方法的实现。以分号结束：比如：public abstract void talk()<strong>;</strong> </li>
<li> 含有抽象方法的类必须被声明为抽象类。 </li>
<li> 抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。 </li>
<li> 不能用abstract修饰变量、代码块、构造器； </li>
<li> 不能用abstract修饰私有方法、静态方法、final的方法、final的类。 </li>
</ul>
<img src="/post/8df0ec14/1668175624961-132e7b62-0f16-4707-9178-86dd6466dbb8.png" class="" title="image-20220512084354489.png">

<img src="/post/8df0ec14/1668175630850-ee7af6d0-7249-4e2a-bcd7-78a2f7f3cb9d.png" class="" title="image-20220512084418037.png">

<h3 id="多态的应用：模板方法设计模式-TemplateMethod"><a href="#多态的应用：模板方法设计模式-TemplateMethod" class="headerlink" title="多态的应用：模板方法设计模式(TemplateMethod)"></a><strong>多态的应用：模板方法设计模式</strong>(TemplateMethod)</h3><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<ul>
<li>解决的问题： <ul>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，<strong>这些步骤已经在父类中写好了</strong>。但是某些部分<strong>易变</strong>，易变部分可以<strong>抽象出来</strong>，供<strong>不同子类实现</strong>。这就是一种<strong>模板模式</strong>。</li>
</ul>
</li>
</ul>
<p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p>
<ul>
<li>数据库访问的封装<br> Junit单元测试<br> JavaWeb的Servlet中关于doGet/doPost方法调用<br> Hibernate中模板程序<br> Spring中JDBCTemlate、HibernateTemplate等 </li>
</ul>
<h2 id="4-16、-接口-interface"><a href="#4-16、-接口-interface" class="headerlink" title="4.16、 接口(interface)"></a>4.16、 接口(interface)</h2><ul>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能”的关系。</li>
<li>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</li>
</ul>
<img src="/post/8df0ec14/1668175637556-584c267e-c0a0-4c59-8161-9e70a07b8308.png" class="" title="image-20220512090123928.png">

<ul>
<li> 接口(interface)是抽象方法和常量值定义的集合。 </li>
<li>接口的特点： <ul>
<li> 用interface来定义。 </li>
<li> 接口中的所有成员变量都默认是由public static final修饰的。 </li>
<li> 接口中的所有抽象方法都默认是由public abstract修饰的。 </li>
<li> 接口中没有构造器。 </li>
<li> 接口采用多继承机制。 </li>
<li> <img src="/post/8df0ec14/1668175643742-db502956-ff29-4521-bd0f-689a65c82fc9.png" class="" title="image-20220512090244652.png"></li>
</ul>
</li>
<li><h2 id="定义Java类的语法格式：先写extends，后写implements"><a href="#定义Java类的语法格式：先写extends，后写implements" class="headerlink" title="定义Java类的语法格式：先写extends，后写implements "></a>定义Java类的语法格式：先写<strong>extends</strong>，后写implements </h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>&#123; &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li> 一个类可以实现多个接口，接口也可以继承其它接口。 </li>
<li> 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。 </li>
<li> 接口的主要用途就是被实现类实现。（面向接口编程） </li>
<li> 与继承关系类似，接口与实现类之间存在多态性 </li>
<li> 接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。 </li>
<li> <img src="/post/8df0ec14/1668175682411-d9e748f4-2f26-4f30-8f82-f727168e4752.png" class="" title="image-20220512090524088.png"></li>
</ul>
<h3 id="接口的应用：代理模式-Proxy"><a href="#接口的应用：代理模式-Proxy" class="headerlink" title="接口的应用：代理模式(Proxy)"></a>接口的应用：代理模式(Proxy)</h3><p><strong>概述：</strong>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p>
<h1 id="第五章、异常处理"><a href="#第五章、异常处理" class="headerlink" title="第五章、异常处理"></a>第五章、异常处理</h1><h2 id="5-1、-异常概述与异常体系结构"><a href="#5-1、-异常概述与异常体系结构" class="headerlink" title="5.1、 异常概述与异常体系结构"></a>5.1、 异常概述与异常体系结构</h2><ul>
<li>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。（语法错误和逻辑错误不是异常）</li>
<li>java程序在执行过程中所发生的异常时间可分为两类： <ul>
<li>Error：Java虚拟机无法解决的严重问题。如jvm系统内部错误、资源的耗尽等严重错误。</li>
<li>Exception：其他因为边查错误或者偶然的外在因素造成的一般性问题，就可以使用针对性代码进行处理。 <ul>
<li>空指针异常</li>
<li>试图读取不存在的文件</li>
<li>网络链接中断</li>
<li>数据角标越界</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2、-常见异常"><a href="#5-2、-常见异常" class="headerlink" title="5.2、 常见异常"></a>5.2、 常见异常</h2><ul>
<li> java.lang.RuntimeException </li>
<li> ClassCastException（类型转换异常） </li>
<li> ArrayIndexOutOfBoundsException（数组角标越界） </li>
<li> NullPointerException（空指针异常） </li>
<li> ArithmeticException（算数异常） </li>
<li> NumberFormatException（数值类型错误） </li>
<li> InputMismatchException（输入异常） </li>
<li> 。。。 </li>
<li> java.io.IOExeption </li>
<li> FileNotFoundException </li>
<li> EOFException </li>
</ul>
<h2 id="5-3、-异常处理机制一、try-catch-finally"><a href="#5-3、-异常处理机制一、try-catch-finally" class="headerlink" title="5.3、 异常处理机制一、try-catch-finally"></a>5.3、 异常处理机制一、try-catch-finally</h2><p>分为两类：</p>
<ul>
<li> try-catch-finally </li>
<li> throws + 异常类型 </li>
<li>处理机制： <ul>
<li>java提供的是异常处理的<strong>抓抛模型</strong></li>
<li>java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行是系统，这个过程称为抛出（throw）异常。</li>
<li>▲异常对象的生成（原理） <ul>
<li>有虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果子啊当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出—自动抛出</li>
<li>有开发人员手动创建：<code>Exception exception = new ClassCastexception();</code>    创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样</li>
</ul>
</li>
<li>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处<br>理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。<br>这一过程称为捕获(catch)异常。</li>
<li>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。</li>
<li>程序员通常只能处理Exception，而对Error无能为力。</li>
</ul>
</li>
<li> try-catch-finally实现： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...... <span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName1 e )&#123;</span><br><span class="line">...... <span class="comment">//当产生ExceptionName1型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName2 e )&#123;</span><br><span class="line">...... <span class="comment">//当产生ExceptionName2型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line">[ <span class="keyword">finally</span>&#123;</span><br><span class="line">...... <span class="comment">//无论是否发生异常，都无条件执行的语句</span></span><br><span class="line">&#125; ]</span><br></pre></td></tr></table></figure>


<ul>
<li>try<br> 捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现<br> 异常的代码放在try语句块中。 </li>
<li>catch (Exceptiontype e)<br> 在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随<br> 一个或多个catch语句，用于处理可能产生的不同类型的异常对象。 <ul>
<li>如果明确知道了产生何种异常，可以用该异常类作为catch的参数，也可以用其父类作为catch的参数</li>
<li>如果字符类异常字符类都有，则要按顺序放（子前父后）</li>
<li>捕获异常的有关信息： <ul>
<li>getMessage（） 获取异常信息，返回字符串</li>
<li>printStackTrace()  获取异常类名和异常信息，以及异常出现在程序中的位置。返回值是<strong>void</strong></li>
</ul>
</li>
</ul>
</li>
<li>finally <ul>
<li>捕获异常的最后一部是通过finally语句为异常处理提供一个统一的出口（一定会执行）</li>
<li>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。</li>
<li>finally语句中也能允许有异常存在，若是有return的话，则语句会从finally的return出去</li>
</ul>
</li>
<li> finally语句和catch语句是任选的 </li>
</ul>
<h2 id="5-4、-异常处理机制二、throws-异常类型"><a href="#5-4、-异常处理机制二、throws-异常类型" class="headerlink" title="5.4、 异常处理机制二、throws + 异常类型"></a>5.4、 异常处理机制二、throws + 异常类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 如果一个方法中（中的语句执行时）可能生成某种异常，都是并不能缺点如何处理这种异常，则此方法应**显示地**声明抛出异常，表明该方法不对这些异常进行处理，而由该方法的调用者法则处理。（暂时抛出异常，然后再由调用者去捕获处理，可嵌套多个调用者，由最后一个处理）</span><br><span class="line">- 在方法声明中用<span class="keyword">throws</span>语句可以声明抛出异常的列表，<span class="keyword">throws</span> 后面的异常类型可</span><br></pre></td></tr></table></figure>

<p>以是方法中产生的异常类型，也可以是它的父类。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">ThrowsTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThrowsTest</span>();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		t.readFile();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;atguigushk.txt&quot;</span>);</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	b = in.read();</span><br><span class="line">	<span class="keyword">while</span> (b != -<span class="number">1</span>) &#123;</span><br><span class="line">		System.out.print((<span class="type">char</span>) b);</span><br><span class="line">		b = in.read();</span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写方法声明抛出异常的原则 <ul>
<li>重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。</li>
</ul>
</li>
</ul>
<p>☆ try-catch-finally与throws的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span> ：真正的将异常处理掉了</span><br><span class="line"></span><br><span class="line">- <span class="keyword">throws</span> 只是将异常抛给了方法的调用者，并没有真正的处理掉</span><br></pre></td></tr></table></figure>

<h2 id="5-5、-手动抛出异常"><a href="#5-5、-手动抛出异常" class="headerlink" title="5.5、 手动抛出异常"></a>5.5、 手动抛出异常</h2><ul>
<li> 简述：Java异常类对象除了在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。 </li>
<li>首先要生成异常类对象，然后通过throw语句实现抛出操作（提交给Java运行环境） <ul>
<li><code>IOExcption e = new IOException();    throw e;</code></li>
<li>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误： <ul>
<li>throw new String(“want to throw”);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="▲5-6-用户自定义异常类"><a href="#▲5-6-用户自定义异常类" class="headerlink" title="▲5.6 用户自定义异常类"></a>▲5.6 用户自定义异常类</h2><ul>
<li> 一般地，用户自定义异常类都是<code>RuntimeException</code>的子类。 </li>
<li> 自定义异常类通常需要编写几个重载的构造器。 </li>
<li> 自定义异常需要提供serialVersionUID </li>
<li> 自定义的异常通过throw抛出。 </li>
<li> 自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。 </li>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">13465653435L</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> idnumber;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(message);</span><br><span class="line">		<span class="built_in">this</span>.idnumber = id;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> idnumber;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-7-用户自定义异常类"><a href="#5-7-用户自定义异常类" class="headerlink" title="5.7 用户自定义异常类"></a>5.7 用户自定义异常类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExpTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">		<span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;人数为负值，不合理&quot;</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">&quot;登记人数&quot;</span> + num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manager</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		regist(<span class="number">100</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;登记失败，出错种类&quot;</span> + e.getId());</span><br><span class="line">	&#125;</span><br><span class="line">		System.out.print(<span class="string">&quot;本次登记操作结束&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		<span class="type">MyExpTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyExpTest</span>();</span><br><span class="line">		t.manager();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/post/8df0ec14/1668175701929-0f632d88-7d17-4379-9bdc-c54d5aead791.png" class="" title="image-20220325101223297.png">

<h1 id="第六章-多线程"><a href="#第六章-多线程" class="headerlink" title="第六章 多线程"></a>第六章 多线程</h1><h2 id="6-0、内容图解"><a href="#6-0、内容图解" class="headerlink" title="6.0、内容图解"></a>6.0、内容图解</h2><img src="/post/8df0ec14/1668175707024-ee6f067d-f79f-4433-9ff3-d806159e404e.png" class="" title="image-20220920131312142.png">

<h2 id="6-1、基本概念：程序、进程、线程"><a href="#6-1、基本概念：程序、进程、线程" class="headerlink" title="6.1、基本概念：程序、进程、线程"></a>6.1、基本概念：程序、进程、线程</h2><ul>
<li> **程序(program)**是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 </li>
<li>**进程(process)**是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期 <ul>
<li>程序是静态的，进程是动态的</li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
</li>
<li>**线程(thread)**，进程可进一步细化为线程，是一个程序内部的一条执行路径。 <ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开<br>销小</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。<img src="/post/8df0ec14/1668175713605-68d0a9da-aec1-4687-a03d-466bfad3dfd9.png" class="" title="image-20220920143828321.png"></li>
</ul>
</li>
</ul>
<h3 id="6-1-1、单核CPU和多核CPU的理解"><a href="#6-1-1、单核CPU和多核CPU的理解" class="headerlink" title="6.1.1、单核CPU和多核CPU的理解"></a>6.1.1、单核CPU和多核CPU的理解</h3><ul>
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。</li>
<li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
<li>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li>
</ul>
<h3 id="6-1-2、并行与并发"><a href="#6-1-2、并行与并发" class="headerlink" title="6.1.2、并行与并发"></a>6.1.2、并行与并发</h3><ul>
<li><strong>并行：</strong>多个CPU同时执行多个任务。比如：多个人同时做不同的事。</li>
<li><strong>并发：</strong>一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li>
</ul>
<h3 id="6-1-3、使用多线程的优点"><a href="#6-1-3、使用多线程的优点" class="headerlink" title="6.1.3、使用多线程的优点"></a>6.1.3、使用多线程的优点</h3><ul>
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ul>
<h3 id="6-1-4、多线程使用场景"><a href="#6-1-4、多线程使用场景" class="headerlink" title="6.1.4、多线程使用场景"></a>6.1.4、多线程使用场景</h3><ul>
<li>程序需要同时执行两个或多个任务。</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li>
<li>需要一些后台运行的程序时。</li>
</ul>
<h2 id="6-2、线程的创建和使用"><a href="#6-2、线程的创建和使用" class="headerlink" title="6.2、线程的创建和使用"></a>6.2、线程的创建和使用</h2><h3 id="6-2-1、创建和启动"><a href="#6-2-1、创建和启动" class="headerlink" title="6.2.1、创建和启动"></a>6.2.1、创建和启动</h3><ul>
<li>Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。</li>
<li>Thread类的特性 <ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</li>
<li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li>
</ul>
</li>
</ul>
<img src="/post/8df0ec14/1668175721626-d1afbec7-b9f4-467a-8453-5e26271022a3.png" class="" title="image-20220921100531987.png">

<h3 id="6-2-2、API中创建线程的两种方式"><a href="#6-2-2、API中创建线程的两种方式" class="headerlink" title="6.2.2、API中创建线程的两种方式"></a>6.2.2、API中创建线程的两种方式</h3><ul>
<li> 继承Thread类的方式 </li>
<li> 实现Runnable接口的方式 </li>
</ul>
<h4 id="6-2-2-1、方式一：继承Thread类"><a href="#6-2-2-1、方式一：继承Thread类" class="headerlink" title="6.2.2.1、方式一：继承Thread类"></a>6.2.2.1、方式一：继承Thread类</h4><ol>
<li> 定义子类继承Thread类。 </li>
<li> 子类中重写Thread类中的run方法。 </li>
<li> 创建Thread子类对象，即创建了线程对象。 </li>
<li> 调用线程对象start方法：启动线程，调用run方法。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//2. 重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建Thread类的子类的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//4.通过此对象调用start():①启动当前线程 ②调用当前线程的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//问题一：我们不能通过直接调用run()的方式启动线程。</span></span><br><span class="line"><span class="comment">//        t1.run();</span></span><br><span class="line">        <span class="comment">//问题二：再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行。会报IllegalThreadStateException</span></span><br><span class="line"><span class="comment">//        t1.start();</span></span><br><span class="line">        <span class="comment">//我们需要重新创建一个线程的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//如下操作仍然是在main线程中执行的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i + <span class="string">&quot;***********main()************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意： <ul>
<li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU<br>调度决定。</li>
<li>想要启动多线程，必须调用start方法。</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上<br>的异常“IllegalThreadStateException”。</li>
</ul>
</li>
</ul>
<h4 id="6-2-2-2、方式二：实现Runnable接口"><a href="#6-2-2-2、方式二：实现Runnable接口" class="headerlink" title="6.2.2.2、方式二：实现Runnable接口"></a>6.2.2.2、方式二：实现Runnable接口</h4><ol>
<li> 定义子类，实现Runnable接口。 </li>
<li> 子类中重写Runnable接口中的run方法。 </li>
<li> 通过Thread类含参构造器创建线程对象。 </li>
<li> 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。 </li>
<li> 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">MThread</span> <span class="variable">mThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MThread</span>();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;调用了Runnable类型的target的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程，遍历100以内的偶数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-3、继承方式和实现方式的联系与区别"><a href="#6-2-3、继承方式和实现方式的联系与区别" class="headerlink" title="6.2.3、继承方式和实现方式的联系与区别"></a>6.2.3、继承方式和实现方式的联系与区别</h3><ul>
<li><strong>区别</strong>： <ul>
<li>继承Thread：线程代码存放Thread子类run方法中。</li>
<li>实现Runnable：线程代码存在接口的子类的run方法。</li>
</ul>
</li>
<li><strong>实现方式的好处</strong> <ul>
<li>避免了单继承的局限性</li>
<li>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线<br>程来处理同一份资源。</li>
</ul>
</li>
</ul>
<h3 id="6-2-4、Thread相关API"><a href="#6-2-4、Thread相关API" class="headerlink" title="6.2.4、Thread相关API"></a>6.2.4、Thread相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>: 启动线程，并执行对象的run()方法</span><br><span class="line">run(): 线程在被调度时执行的操作</span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>: 返回线程的名称</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>:设置该线程名称</span><br><span class="line"><span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>: 返回当前线程。在Thread子类中就是<span class="built_in">this</span>，通常用于主线程和Runnable实现类</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>：线程让步</span><br><span class="line">    <span class="comment">//暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</span></span><br><span class="line">	<span class="comment">//若队列中没有同优先级的线程，忽略此方法</span></span><br><span class="line">join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止</span><br><span class="line">	<span class="comment">//低优先级的线程也可以获得执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span>：(指定时间:毫秒) </span><br><span class="line">    <span class="comment">//令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。</span></span><br><span class="line">	<span class="comment">//抛出InterruptedException异常</span></span><br><span class="line">stop(): 强制线程生命期结束，不推荐使用</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>：返回<span class="type">boolean</span>，判断线程是否还活着</span><br></pre></td></tr></table></figure>

<h3 id="6-2-5、线程的调度"><a href="#6-2-5、线程的调度" class="headerlink" title="6.2.5、线程的调度"></a>6.2.5、线程的调度</h3><ul>
<li>调度策略 <ul>
<li>抢占式：高优先级的线程抢占CPU</li>
<li>时间片：</li>
</ul>
</li>
</ul>
<img src="/post/8df0ec14/1668175745182-d37818a9-bbe5-4c87-bbb7-773ca461170e.png" class="" title="image-20220921102413129.png">

<ul>
<li>Java的调度方法 <ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略、</li>
</ul>
</li>
</ul>
<h3 id="6-2-6、线程的优先级"><a href="#6-2-6、线程的优先级" class="headerlink" title="6.2.6、线程的优先级"></a>6.2.6、线程的优先级</h3><ul>
<li>线程的优先级等级（常量） <ul>
<li>MAX_PRIORITY：10</li>
<li>MIN _PRIORITY：1</li>
<li>NORM_PRIORITY：5</li>
</ul>
</li>
<li>涉及的方法 <ul>
<li><strong>getPriority()</strong> <strong>：</strong>返回线程优先值</li>
<li><strong>setPriority(int newPriority)</strong> <strong>：</strong>改变线程的优先级</li>
</ul>
</li>
<li>说明： <ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是再高优先级线程之后才被调用</li>
</ul>
</li>
</ul>
<h3 id="6-2-7、线程的分类"><a href="#6-2-7、线程的分类" class="headerlink" title="6.2.7、线程的分类"></a>6.2.7、线程的分类</h3><p>Java中的线程分为两类：一种是<strong>守护线程</strong>，一种是<strong>用户线程</strong>。</p>
<ul>
<li>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。</li>
<li>守护线程是用来服务用户线程的，通过在start()方法前调用<br>thread.setDaemon(true)可以把一个用户线程变成一个守护线程。</li>
<li>Java垃圾回收就是一个典型的守护线程。</li>
<li>若JVM中都是守护线程，当前JVM将退出。</li>
<li>形象理解：兔死狗烹，鸟尽弓藏</li>
</ul>
<h2 id="6-3、线程的生命周期"><a href="#6-3、线程的生命周期" class="headerlink" title="6.3、线程的生命周期"></a>6.3、线程的生命周期</h2><p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类</p>
<p>及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的<strong>五种状态</strong>：</p>
<ul>
<li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<img src="/post/8df0ec14/1668175755417-b18dd671-63a2-4855-a4cf-efa5e235f0d2.png" class="" title="线程的生命周期.png">

<h2 id="6-4、线程的同步"><a href="#6-4、线程的同步" class="headerlink" title="6.4、线程的同步"></a>6.4、线程的同步</h2><ul>
<li>线程存在问题： <ul>
<li>多个线程执行的不确定性引起执行结果的不稳定</li>
<li>多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</li>
</ul>
</li>
</ul>
<img src="/post/8df0ec14/1668175760787-9e58b65e-4b51-4157-8c82-30b1968d5b16.png" class="" title="image-20220921170803391.png">

<ol>
<li>多线程出现了安全问题</li>
<li>问题的原因：<br>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有<br>执行完，另一个线程参与进来执行。导致共享数据的错误。</li>
<li>解决办法：<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以<br>参与执行。</li>
</ol>
<h3 id="6-4-1、Synchronized的使用方法"><a href="#6-4-1、Synchronized的使用方法" class="headerlink" title="6.4.1、Synchronized的使用方法"></a>6.4.1、<strong>Synchronized的使用方法</strong></h3><ul>
<li> <strong>Java</strong>对于多线程的安全问题提供了专业的解决方式：<strong>同步机制</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 同步代码块：</span><br><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line"><span class="comment">// 需要被同步的代码；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> <span class="keyword">synchronized</span>还可以放在方法声明中，表示整个方法为同步方法。</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String name)</span>&#123; </span><br><span class="line">….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-4-2、同步机制中的锁"><a href="#6-4-2、同步机制中的锁" class="headerlink" title="6.4.2、同步机制中的锁"></a>6.4.2、同步机制中的锁</h3><ul>
<li><strong>同步锁机制：</strong> <ul>
<li>在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</li>
</ul>
</li>
<li><strong>Synchronized的锁是什么？</strong> <ul>
<li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。</li>
<li>同步方法的锁：静态方法（类名.class）、非静态方法（this）</li>
<li>同步代码块：自己指定，很多时候也是指定为this或类名.class</li>
</ul>
</li>
<li>注意： <ul>
<li>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全</li>
<li>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</li>
</ul>
</li>
</ul>
<h4 id="6-4-2-1、同步的范围"><a href="#6-4-2-1、同步的范围" class="headerlink" title="6.4.2.1、同步的范围"></a>6.4.2.1、同步的范围</h4><ul>
<li><strong>如何找问题，即代码是否存在线程安全</strong>？（非常重要的） <ul>
<li>明确哪些代码是多线程运行的代码</li>
<li>明确多个线程是否有共享数据</li>
<li>明确多线程运行代码中是否有多条语句操作共享数据</li>
</ul>
</li>
<li><strong>如何解决问题</strong>？（非常重要*2） <ul>
<li>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。<br> 即所有操作共享数据的这些语句都要放在同步范围中 </li>
</ul>
</li>
<li>注意点： <ul>
<li>范围太小：没锁住所有有安全问题的代码</li>
<li>范围太大：没发挥多线程的功能。</li>
</ul>
</li>
</ul>
<h4 id="6-4-2-2、释放锁的操作"><a href="#6-4-2-2、释放锁的操作" class="headerlink" title="6.4.2.2、释放锁的操作"></a>6.4.2.2、释放锁的操作</h4><ul>
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的**wait()**方法，当前线程暂停，并释放锁。</li>
</ul>
<h4 id="6-4-2-3、不会释放锁的操作"><a href="#6-4-2-3、不会释放锁的操作" class="headerlink" title="6.4.2.3、不会释放锁的操作"></a>6.4.2.3、<strong>不会释放锁的操作</strong></h4><ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。 <ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
<h3 id="6-4-3、单例设计模式之懒汉式-线程安全"><a href="#6-4-3、单例设计模式之懒汉式-线程安全" class="headerlink" title="6.4.3、单例设计模式之懒汉式(线程安全)"></a>6.4.3、单例设计模式之懒汉式(线程安全)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-4、线程的死锁问题"><a href="#6-4-4、线程的死锁问题" class="headerlink" title="6.4.4、线程的死锁问题"></a>6.4.4、线程的死锁问题</h3><ul>
<li>死锁 <ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
</ul>
</li>
<li>解决方案 <ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
</li>
</ul>
<h3 id="6-4-5、Lock-锁"><a href="#6-4-5、Lock-锁" class="headerlink" title="6.4.5、Lock(锁)"></a>6.4.5、Lock(锁)</h3><ul>
<li> 从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。 </li>
<li> ==java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。==锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 </li>
<li> ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//保证线程安全的代码; &#125;</span></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   注意：如果同步代码有异常，要将unlock()写入<span class="keyword">finally</span>语句块</span><br></pre></td></tr></table></figure>

<h3 id="6-4-6、synchronized-与-Lock-的对比"><a href="#6-4-6、synchronized-与-Lock-的对比" class="headerlink" title="6.4.6、synchronized 与 Lock 的对比"></a>6.4.6、synchronized 与 Lock 的对比</h3><ul>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
</ul>
<img src="/post/8df0ec14/1668175779625-06d44788-455a-42a7-a167-c034e192adf8.png" class="" title="image-20220921180045001.png">

<h2 id="6-5、线程的通信"><a href="#6-5、线程的通信" class="headerlink" title="6.5、线程的通信"></a>6.5、线程的通信</h2><p>例题：使用两个线程打印 1-100。线程1, 线程2 交替打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Communication</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                            <span class="string">&quot;:&quot;</span> + i++);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>wait()</strong> <strong>与</strong> <strong>notify()</strong> <strong>和</strong> <strong>notifyAll()</strong> <ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>
<li>notifyAll()：唤醒正在排队等待资源的所有线程结束等待。</li>
</ul>
</li>
<li> 这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。 </li>
<li>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，<br> 因此这三个方法只能在Object类中声明。 </li>
</ul>
<h4 id="6-5-1、wait（）方法"><a href="#6-5-1、wait（）方法" class="headerlink" title="6.5.1、wait（）方法"></a>6.5.1、wait（）方法</h4><ul>
<li>在当前线程中调用方法： 对象名.wait()</li>
<li>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
<li><strong>调用此方法后，当前线程将释放对象监控权 （释放锁），然后进入等待</strong></li>
<li>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li>
</ul>
<h5 id="6-5-1-1、wait（）方法与sleep方法的区别"><a href="#6-5-1-1、wait（）方法与sleep方法的区别" class="headerlink" title="6.5.1.1、wait（）方法与sleep方法的区别"></a>6.5.1.1、wait（）方法与sleep方法的区别</h5><ul>
<li>相同点： <ul>
<li>一旦执行方法，都可以使得当前的线程进入阻塞状态。</li>
</ul>
</li>
<li>不同点： <ul>
<li>声明位置不同：Thread类中声明sleep（），Object类中声明wait（）。</li>
<li>调用要求不同：sleep()可以在如何需要的场景下调用。wait()必须使用在同步代码中。</li>
<li>关于释放同步器：如果来个方法都是用在同步代码块或者同步方法中，sleep()不释放锁，wait()释放锁。</li>
</ul>
</li>
</ul>
<h4 id="6-5-2、notify-notifyAll"><a href="#6-5-2、notify-notifyAll" class="headerlink" title="6.5.2、notify()/notifyAll()"></a>6.5.2、<strong>notify()/notifyAll()</strong></h4><ul>
<li>在当前线程中调用方法： 对象名.notify()</li>
<li>功能：唤醒等待该对象监控权的一个/所有线程。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
</ul>
<h4 id="6-5-3、经典例题：生产者-消费者问题"><a href="#6-5-3、经典例题：生产者-消费者问题" class="headerlink" title="6.5.3、经典例题：生产者/消费者问题"></a>6.5.3、经典例题：生产者/消费者问题</h4><blockquote>
<p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p>
<ul>
<li>这里可能出现两个问题： <ul>
<li> 生产者比消费者快时，消费者会漏掉一些数据没有取到。 </li>
<li> 消费者比生产者快时，消费者会取相同的数据 </li>
</ul>
</li>
</ul>
</blockquote>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123; <span class="comment">// 售货员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product++;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了</span></span><br><span class="line"><span class="string">                    第&quot;</span> + product + <span class="string">&quot; 个产品&quot;</span>);</span><br><span class="line">                    notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                               </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取走了第&quot;</span> +</span><br><span class="line">                    product + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            product--;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                               </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Productor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">// 生产者</span></span><br><span class="line">    Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者开始生产产品&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">int</span>) Math.random() * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.addProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">// 消费者</span></span><br><span class="line">    Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者开始取走产品&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">int</span>) Math.random() * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.getProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">productorThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Productor</span>(clerk));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk));</span><br><span class="line">        productorThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6、JDK5-0新增线程创建方式"><a href="#6-6、JDK5-0新增线程创建方式" class="headerlink" title="6.6、JDK5.0新增线程创建方式"></a>6.6、JDK5.0新增线程创建方式</h3><h4 id="6-6-1、新增方式一：实现Callable接口"><a href="#6-6-1、新增方式一：实现Callable接口" class="headerlink" title="6.6.1、新增方式一：实现Callable接口"></a>6.6.1、新增方式一：实现Callable接口</h4><ul>
<li>与使用Runnable相比， Callable功能更强大些 <ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
</ul>
</li>
<li>Future接口 <ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的方式三：实现Callable接口。 --- JDK 5.0新增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</span></span><br><span class="line"><span class="comment"> * 1. call()可以有返回值的。</span></span><br><span class="line"><span class="comment"> * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息</span></span><br><span class="line"><span class="comment"> * 3. Callable是支持泛型的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-15 下午 6:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-6-2、新增方式二：使用线程池"><a href="#6-6-2、新增方式二：使用线程池" class="headerlink" title="6.6.2、新增方式二：使用线程池"></a>6.6.2、新增方式二：使用线程池</h4><ul>
<li><strong>背景</strong>：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</li>
<li><strong>思路：</strong>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
<li><strong>好处：</strong> <ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理</li>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>…</li>
</ul>
</li>
</ul>
<h5 id="6-6-2-1、线程池相关api"><a href="#6-6-2-1、线程池相关api" class="headerlink" title="6.6.2.1、线程池相关api"></a>6.6.2.1、线程池相关api</h5><ul>
<li>JDK 5.0起提供了线程池相关API：<strong>ExecutorService</strong> 和 <strong>Executors</strong></li>
<li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor <ul>
<li>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li>Future submit(Callable task)：执行任务，有返回值，一般又来执行Callable</li>
<li>void shutdown() ：关闭连接池</li>
</ul>
</li>
<li><strong>Executors</strong>：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 <ul>
<li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</li>
<li>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池</li>
<li>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的方式四：使用线程池</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 好处：</span></span><br><span class="line"><span class="comment"> * 1.提高响应速度（减少了创建新线程的时间）</span></span><br><span class="line"><span class="comment"> * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）</span></span><br><span class="line"><span class="comment"> * 3.便于线程管理</span></span><br><span class="line"><span class="comment"> * corePoolSize：核心池的大小</span></span><br><span class="line"><span class="comment"> * maximumPoolSize：最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime：线程没有任务时最多保持多长时间后会终止</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-15 下午 6:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第七章-常用类"><a href="#第七章-常用类" class="headerlink" title="第七章 常用类"></a>第七章 常用类</h1><h2 id="7-0、内容图解"><a href="#7-0、内容图解" class="headerlink" title="7.0、内容图解"></a>7.0、内容图解</h2><img src="/post/8df0ec14/1668175801097-e6e22ce7-06a8-48ad-9ab6-6e255550e923.png" class="" title="image-20220924104231496.png">

<img src="/post/8df0ec14/1668175807071-f76a4e07-9d06-43a0-b3fb-1f8c95bd1ce1.png" class="" title="image-20220924104250590.png">

<h2 id="7-1、字符串相关的类：String"><a href="#7-1、字符串相关的类：String" class="headerlink" title="7.1、字符串相关的类：String"></a>7.1、字符串相关的类：String</h2><h3 id="7-1-1、String的特性"><a href="#7-1-1、String的特性" class="headerlink" title="7.1.1、String的特性"></a>7.1.1、String的特性</h3><ul>
<li>String类：代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作<br> 为此类的实例实现。 </li>
<li> String是一个final类，代表不可变的字符序列，且不可被继承。 </li>
<li> 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改，在常量池中是不会存储相同内容。 </li>
<li> String对象的字符内容是存储在一个字符数组value[]中的。 </li>
<li>string实现了<strong>Serializable接口</strong>：表示字符串是支持序列化的<pre><code> 实现了**Comparable接口**：表示String可以比较大小 
</code></pre>
</li>
</ul>
<img src="/post/8df0ec14/1668175813113-7c8ada58-9216-4a68-8a55-9a04e54ed394.png" class="" title="image-20220925142649247.png">

<img src="/post/8df0ec14/1668175818235-163b258e-5f60-49ef-a855-83b0ced4ede9.png" class="" title="image-20220925142730566.png">

<img src="/post/8df0ec14/1668175823537-2d077cb1-e02f-4200-9dcd-75a588431d7b.png" class="" title="image-20220925142907614.png">

<p><strong>结论：</strong></p>
<ul>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li>
<li>只要其中有一个是变量，结果就在堆中</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中</li>
<li>string因为是不可变性，所以在创建时就固定了底层的Char[]的长度，如果需要追加则会在常量池新建一个空间存放新的string</li>
<li></li>
</ul>
<h3 id="7-1-2、String使用陷阱"><a href="#7-1-2、String使用陷阱" class="headerlink" title="7.1.2、String使用陷阱"></a>7.1.2、<strong>String使用陷阱</strong></h3><ul>
<li>String s1 = “a”;<br> 说明：在字符串常量池中创建了一个字面量为”a”的字符串。 </li>
<li>s1 = s1 + “b”;<br> 说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。 </li>
<li>String s2 = “ab”;<br> 说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。 </li>
<li>String s3 = “a” + “b”;<br> 说明：s3指向字符串常量池中已经创建的”ab”的字符串。 </li>
<li>String s4 = s1.intern();<br> 说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。 </li>
</ul>
<h3 id="7-1-3、string常用方法"><a href="#7-1-3、string常用方法" class="headerlink" title="7.1.3、string常用方法"></a>7.1.3、string常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">★<span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>：返回字符串的长度： <span class="keyword">return</span> value.length</span><br><span class="line">★<span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>： 返回某索引处的字符<span class="keyword">return</span> value[index]  <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：判断是否是空字符串：<span class="keyword">return</span> value.length == <span class="number">0</span> </span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span><br><span class="line">★<span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span><br><span class="line">★String <span class="title function_">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+” </span><br><span class="line">★<span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span><br><span class="line">★<span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix, <span class="type">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span><br><span class="line">String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span><br><span class="line">String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span><br><span class="line">String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span> ：使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。</span><br><span class="line">String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span> ：使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span><br><span class="line">String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">String[] split(String regex, <span class="type">int</span> limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中</span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12hello34world5java7891mysql456&quot;</span>;</span><br><span class="line"><span class="comment">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;,&quot;</span>).replaceAll(<span class="string">&quot;^,|,$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(string);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="comment">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> str.matches(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">System.out.println(matches);</span><br><span class="line"><span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> <span class="string">&quot;0571-4534289&quot;</span>;</span><br><span class="line"><span class="comment">//判断这是否是一个杭州的固定电话</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tel.matches(<span class="string">&quot;0571-\\d&#123;7,8&#125;&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<h3 id="7-1-4、字符串相关的类：String与基本数据类型转换"><a href="#7-1-4、字符串相关的类：String与基本数据类型转换" class="headerlink" title="7.1.4、字符串相关的类：String与基本数据类型转换"></a>7.1.4、<strong>字符串相关的类：String与基本数据类型转换</strong></h3><ul>
<li>字符串 –&gt;基本数据类型、包装类 <ul>
<li>Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。</li>
<li>类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</li>
<li>基本数据类型、包装类 –&gt; 字符串</li>
<li>调用String类的<code>public String valueOf(int n)</code>可将int型转换为字符串</li>
<li>相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换</li>
</ul>
</li>
<li>字符数组 –&gt;字符串 <ul>
<li>String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。</li>
</ul>
</li>
<li> 字符串–&gt;字符数组 </li>
<li>public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组<br> 中的方法。 </li>
<li> public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。 </li>
<li>字节数组–&gt;字符串 <ul>
<li>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</li>
</ul>
</li>
<li> 字符串–&gt;字节数组 </li>
<li> public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。 </li>
<li> public byte[] getBytes(String charsetName) ：使用指定的字符集将 此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 </li>
</ul>
<h3 id="7-1-5、String转化为StringBuffer、StringBuilder"><a href="#7-1-5、String转化为StringBuffer、StringBuilder" class="headerlink" title="7.1.5、String转化为StringBuffer、StringBuilder"></a>7.1.5、String转化为StringBuffer、StringBuilder</h3><p>调用StringBuffer、StringBuilder的构造器</p>
<h3 id="7-1-6、StringBuffer、StringBuilder-转换为String"><a href="#7-1-6、StringBuffer、StringBuilder-转换为String" class="headerlink" title="7.1.6、StringBuffer、StringBuilder 转换为String"></a>7.1.6、StringBuffer、StringBuilder 转换为String</h3><p>调用Stringd 给构造器、StringBuffer、StringBuilder的toString</p>
<h2 id="7-2、字符串相关的类：StringBuffer类"><a href="#7-2、字符串相关的类：StringBuffer类" class="headerlink" title="7.2、字符串相关的类：StringBuffer类"></a>7.2、字符串相关的类：<strong>StringBuffer类</strong></h2><h3 id="7-2-1、StringBuffer类特性"><a href="#7-2-1、StringBuffer类特性" class="headerlink" title="7.2.1、StringBuffer类特性"></a>7.2.1、StringBuffer类特性</h3><ul>
<li>java.lang.StringBuffer代表<strong>可变的字符序列</strong>，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。</li>
<li>很多方法与String相同。</li>
<li>作为参数传递时，方法内部可以改变值。</li>
<li>可动态扩容。</li>
<li>StringBuffer类不同于String，其对象必须使用构造器生成。有三个构造器： <ul>
<li>StringBuffer()：初始容量为16的字符串缓冲区</li>
<li>StringBuffer(int size)：构造指定容量的字符串缓冲区</li>
<li>StringBuffer(String str)：将内容初始化为指定字符串内容</li>
</ul>
</li>
</ul>
<img src="/post/8df0ec14/1668175886244-8d63e934-0456-431c-9435-57901b5e09b0.png" class="" title="image-20220925144549886.png">

<h3 id="7-2-2、StringBuffer类的常用方法"><a href="#7-2-2、StringBuffer类的常用方法" class="headerlink" title="7.2.2、StringBuffer类的常用方法"></a>7.2.2、<strong>StringBuffer类的常用方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer <span class="title function_">append</span><span class="params">(xxx)</span>：提供了很多的append()方法，用于进行字符串拼接</span><br><span class="line">StringBuffer <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>：删除指定位置的内容</span><br><span class="line">StringBuffer <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String str)</span>：把[start,end)位置替换为str</span><br><span class="line">StringBuffer <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, xxx)</span>：在指定位置插入xxx</span><br><span class="line">StringBuffer <span class="title function_">reverse</span><span class="params">()</span> ：把当前字符序列逆转</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>	返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。 返回的整数是最小值k ，</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span> 返回一个新的 String ，其中包含此序列中当前包含的字符的子序列。</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> 返回长度（字符数）。 </span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> n )</span> 返回 <span class="type">char</span>在指定索引在这个序列值。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> n ,<span class="type">char</span> ch)</span> 指定索引处的字符设置为 ch 。</span><br></pre></td></tr></table></figure>

<h2 id="7-3、字符串相关的类：StringBuilder类"><a href="#7-3、字符串相关的类：StringBuilder类" class="headerlink" title="7.3、字符串相关的类：StringBuilder类"></a>7.3、字符串相关的类：StringBuilder类</h2><ul>
<li> <strong>StringBuilder</strong> <strong>和</strong> <strong>StringBuffer</strong> <strong>非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样</strong> </li>
<li><strong>面试题：对比String</strong>、<strong>StringBuffer</strong>、<strong>StringBuilder</strong> <ul>
<li>String(JDK1.0)：不可变字符序列，效率最低、线程<strong>安全</strong></li>
<li>StringBuffer(JDK1.0)：可变字符序列、效率低、线程<strong>安全</strong></li>
<li>StringBuilder(JDK 5.0)：可变字符序列、效率高、线程<strong>不安全</strong></li>
</ul>
</li>
</ul>
<p>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。</p>
<pre><code>        因为string和stringBuffer方法里都带有synchronized关键字，为共享数据加了锁，所以是线程安全的
</code></pre>
<h2 id="7-4、JDK8之前日期时间API"><a href="#7-4、JDK8之前日期时间API" class="headerlink" title="7.4、JDK8之前日期时间API"></a>7.4、JDK8之前日期时间API</h2><img src="/post/8df0ec14/1668175894516-4a62e4fc-9977-4dcd-90be-a76a2a724401.png" class="" title="image-20220925151752733.png">     

<h3 id="7-4-1、-java-lang-System类"><a href="#7-4-1、-java-lang-System类" class="headerlink" title="7.4.1、 java.lang.System类"></a>7.4.1、 java.lang.System类</h3><ul>
<li>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</li>
<li><strong>此方法适于计算时间差。</strong></li>
</ul>
<h3 id="7-4-2、java-util-Date类"><a href="#7-4-2、java-util-Date类" class="headerlink" title="7.4.2、java.util.Date类"></a>7.4.2、<strong>java.util.Date类</strong></h3><p>表示特定的瞬间，精确到毫秒</p>
<ul>
<li>构造器 <ul>
<li><strong>Date()：</strong>使用无参构造器创建的对象可以获取本地当前时间。</li>
<li><strong>Date(long date)</strong></li>
</ul>
</li>
<li>常用方法 <ul>
<li>**getTime():**返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</li>
<li>**toString():**把此 Date 对象转换为以下形式的 String： dow mon ddhh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。</li>
<li>其它很多方法都过时了。</li>
</ul>
</li>
</ul>
<h3 id="7-4-3、SimpleDateFormat类"><a href="#7-4-3、SimpleDateFormat类" class="headerlink" title="7.4.3、SimpleDateFormat类"></a>7.4.3、SimpleDateFormat类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 格式化：</span><br><span class="line"> SimpleDateFormat() ：默认的模式和语言环境创建对象</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">SimpleDateFormat</span><span class="params">(String pattern)</span>：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用：</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(Date date)</span>：方法格式化时间对象date</span><br><span class="line"> 解析：</span><br><span class="line"> <span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span>：从给定字符串的开始解析文本，以生成一个日期。<span class="number">4</span></span><br><span class="line">     </span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 产生一个Date实例</span></span><br><span class="line"><span class="comment">// 产生一个formater格式化的实例</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line">System.out.println(formater.format(date));<span class="comment">// 打印输出默认的格式</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formater2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 EEE HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(formater2.format(date));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 实例化一个指定的格式对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> formater2.parse(<span class="string">&quot;2008年08月08日 星期一 08:08:08&quot;</span>);</span><br><span class="line"><span class="comment">// 将指定的日期解析后格式化按指定的格式输出</span></span><br><span class="line">System.out.println(date2.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-5、JDK8中新日期时间API"><a href="#7-5、JDK8中新日期时间API" class="headerlink" title="7.5、JDK8中新日期时间API"></a>7.5、JDK8中新日期时间API</h2><p>比较常用的五个包：</p>
<ul>
<li>java.time – 包含值对象的基础包</li>
<li>java.time.chrono – 提供对不同的日历系统的访问</li>
<li>java.time.format – 格式化和解析时间和日期</li>
<li>java.time.temporal – 包括底层框架和扩展特性</li>
<li>java.time.zone – 包含时区支持的类</li>
</ul>
<h3 id="7-5-1、-LocalDate、LocalTime、LocalDateTime的使用"><a href="#7-5-1、-LocalDate、LocalTime、LocalDateTime的使用" class="headerlink" title="7.5.1、 LocalDate、LocalTime、LocalDateTime的使用"></a>7.5.1、 LocalDate、LocalTime、LocalDateTime的使用</h3><ul>
<li>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</li>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，而不是日期。</li>
<li>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</li>
</ul>
<p>主要/常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">now() / * now(ZoneId zone) 静态方法，根据当前时间创建对象/指定时区的对象</span><br><span class="line">of() 静态方法，根据指定日期/时间创建对象</span><br><span class="line">getDayOfMonth()/getDayOfYear() 获得月份天数(<span class="number">1</span>-<span class="number">31</span>) /获得年份天数(<span class="number">1</span>-<span class="number">366</span>)</span><br><span class="line">getDayOfWeek() 获得星期几(返回一个 DayOfWeek 枚举值)</span><br><span class="line">getMonth() 获得月份, 返回一个 Month 枚举值</span><br><span class="line">getMonthValue() / getYear() 获得月份(<span class="number">1</span>-<span class="number">12</span>) /获得年份</span><br><span class="line">getHour()/getMinute()/getSecond() 获得当前对象对应的小时、分钟、秒</span><br><span class="line">withDayOfMonth()/withDayOfYear()/</span><br><span class="line">withMonth()/withYear() 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</span><br><span class="line">plusDays(), plusWeeks(), </span><br><span class="line">plusMonths(), plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时</span><br><span class="line">minusMonths() / minusWeeks()/</span><br><span class="line">minusDays()/minusYears()/minusHours() 从当前对象减去几月、几周、几天、几年、几小时</span><br></pre></td></tr></table></figure>

<ul>
<li>使用过程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">①实例化</span><br><span class="line">   <span class="comment">//now():获取当前的日期、时间、日期+时间</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">②调用对应方法</span><br><span class="line">      <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">        System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">        System.out.println(localDateTime.getMonth());</span><br><span class="line">        System.out.println(localDateTime.getMonthValue());</span><br><span class="line">        System.out.println(localDateTime.getMinute());</span><br><span class="line">        <span class="comment">//不可变性</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime3</span> <span class="operator">=</span> localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDateTime3);</span><br></pre></td></tr></table></figure>

<h3 id="7-5-2、瞬时：Instant"><a href="#7-5-2、瞬时：Instant" class="headerlink" title="7.5.2、瞬时：Instant"></a>7.5.2、<strong>瞬时：Instant</strong></h3><ul>
<li> Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。 </li>
<li> 在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。 </li>
</ul>
<p>主要/常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">now() 静态方法，返回默认UTC时区的Instant类的对象</span><br><span class="line">ofEpochMilli(<span class="type">long</span> epochMilli) 静态方法，返回在<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>基础上加上指定毫秒</span><br><span class="line">数之后的Instant类的对象</span><br><span class="line">atOffset(ZoneOffset offset) 结合即时的偏移来创建一个 OffsetDateTime</span><br><span class="line"><span class="title function_">toEpochMilli</span><span class="params">()</span> 返回<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>到当前时间的毫秒数，即为时间戳</span><br></pre></td></tr></table></figure>

<h3 id="7-5-3、格式化与解析日期或时间"><a href="#7-5-3、格式化与解析日期或时间" class="headerlink" title="7.5.3、格式化与解析日期或时间"></a>7.5.3、<strong>格式化与解析日期或时间</strong></h3><ul>
<li>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法： <ul>
<li>预定义的标准格式。如：<strong>ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</strong></li>
<li>本地化相关的格式。如ofLocalizedDateTime(FormatStyle.LONG)</li>
<li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li>
</ul>
</li>
</ul>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ofPattern(String pattern) 静态方法 ， 返 回 一 个 指 定 字 符 串 格 式 的DateTimeFormatter</span><br><span class="line"><span class="title function_">format</span><span class="params">(TemporalAccessor t)</span> 格式化一个日期、时间，返回字符串</span><br><span class="line">parse(CharSequence text) 将指定格式的字符序列解析为一个日期、时间</span><br></pre></td></tr></table></figure>

<h3 id="7-5-4、其他api"><a href="#7-5-4、其他api" class="headerlink" title="7.5.4、其他api"></a>7.5.4、其他api</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</span><br><span class="line">ZonedDateTime：一个在ISO-<span class="number">8601</span>日历系统时区的日期时间，如 <span class="number">2007</span>-<span class="number">12</span>-03T10:<span class="number">15</span>:<span class="number">30</span>+<span class="number">01</span>:<span class="number">00</span> Europe/Paris。  其中每个时区都对应着ID，地区ID都为“&#123;区域&#125;/&#123;城市&#125;”的格式，例如：</span><br><span class="line">Asia/Shanghai等  Clock：使用时区提供对当前即时、日期和时间的访问的时钟。  持续时间：Duration，用于计算两个“时间”间隔</span><br><span class="line">日期间隔：Period，用于计算两个“日期”间隔</span><br><span class="line">TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。</span><br><span class="line">TemporalAdjusters : 该类通过静态方法</span><br><span class="line">(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。</span><br></pre></td></tr></table></figure>

<p>具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZoneId:类中包含了所有的时区信息</span></span><br><span class="line"><span class="comment">// ZoneId的getAvailableZoneIds():获取所有的ZoneId</span></span><br><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line"><span class="keyword">for</span> (String s : zoneIds) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ZoneId的of():获取指定时区的时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"><span class="comment">//ZonedDateTime:带时区的日期时间</span></span><br><span class="line"><span class="comment">// ZonedDateTime的now():获取本时区的ZonedDateTime对象</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">System.out.println(zonedDateTime);</span><br><span class="line"><span class="comment">// ZonedDateTime的now(ZoneId id):获取指定时区的ZonedDateTime对象</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime1</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">System.out.println(zonedDateTime1);</span><br><span class="line"><span class="comment">//Duration:用于计算两个“时间”间隔，以秒和纳秒为基准</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localTime1, localTime);</span><br><span class="line">System.out.println(duration);</span><br><span class="line">System.out.println(duration.getSeconds());</span><br><span class="line">System.out.println(duration.getNano());</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line">System.out.println(duration1.toDays());</span><br><span class="line"><span class="comment">//Period:用于计算两个“日期”间隔，以年、月、日衡量</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2028</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate, localDate1);</span><br><span class="line">System.out.println(period);</span><br><span class="line">System.out.println(period.getYears());</span><br><span class="line">System.out.println(period.getMonths());</span><br><span class="line">System.out.println(period.getDays());</span><br><span class="line"><span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> period.withYears(<span class="number">2</span>);</span><br><span class="line">System.out.println(period1)；</span><br><span class="line"><span class="comment">// TemporalAdjuster:时间校正器</span></span><br><span class="line"><span class="comment">// 获取当前日期的下一个周日是哪天？</span></span><br><span class="line"><span class="type">TemporalAdjuster</span> <span class="variable">temporalAdjuster</span> <span class="operator">=</span> TemporalAdjusters.next(DayOfWeek.SUNDAY);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now().with(temporalAdjuster);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"><span class="comment">// 获取下一个工作日是哪天？</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now().with(<span class="keyword">new</span> <span class="title class_">TemporalAdjuster</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Temporal <span class="title function_">adjustInto</span><span class="params">(Temporal temporal)</span> &#123;</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> (LocalDate) temporal;</span><br><span class="line"><span class="keyword">if</span> (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) &#123;</span><br><span class="line"><span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) &#123;</span><br><span class="line"><span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;下一个工作日是：&quot;</span> + localDate);</span><br></pre></td></tr></table></figure>

<img src="/post/8df0ec14/1668175913943-9555bd95-f6de-4f48-b8c6-ccee402029e9.png" class="" title="image-20220926142335014.png">

<h2 id="7-6、Java比较器（仅了解）"><a href="#7-6、Java比较器（仅了解）" class="headerlink" title="7.6、Java比较器（仅了解）"></a>7.6、Java比较器（仅了解）</h2><p>概述：在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。</p>
<p>分类：</p>
<ul>
<li> <strong>自然排序：java.lang.Comparable</strong> </li>
<li> <strong>定制排序：java.util.Comparator</strong> </li>
</ul>
<h3 id="7-6-1、方式一：自然排序：java-lang-Comparable"><a href="#7-6-1、方式一：自然排序：java-lang-Comparable" class="headerlink" title="7.6.1、方式一：自然排序：java.lang.Comparable"></a>7.6.1、方式一：自然排序：<strong>java.lang.Comparable</strong></h3><ul>
<li> Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 </li>
<li> 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大 于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。 </li>
<li> 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 </li>
<li> 对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。 </li>
<li><strong>Comparable</strong> <strong>的典型实现</strong>：(默认都是从小到大排列的) <ul>
<li>String：按照字符串中字符的Unicode值进行比较</li>
<li>Character：按照字符的Unicode值来进行比较</li>
<li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</li>
<li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li>
<li>Date、Time等：后面的日期时间比前面的日期时间大</li>
</ul>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="comment">//按照价格，比较商品的大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">other</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; other.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; other.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、getter、setter、toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-6-2、方式二：定制排序：java-util-Comparator"><a href="#7-6-2、方式二：定制排序：java-util-Comparator" class="headerlink" title="7.6.2、方式二：定制排序：java.util.Comparator"></a>7.6.2、方式二：定制排序：java.util.Comparator</h3><ul>
<li> 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。 </li>
<li> 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 </li>
<li> 可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。 </li>
<li> 还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">        <span class="comment">//按照价格，比较商品的大小</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">                <span class="type">Goods</span> <span class="variable">other</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; other.price) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; other.price) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//构造器、getter、setter、toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-7、System类"><a href="#7-7、System类" class="headerlink" title="7.7、System类"></a>7.7、System类</h2><ul>
<li> System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 </li>
<li> 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 </li>
<li>成员变量 <ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
</li>
<li>成员方法 <ul>
<li>native long currentTimeMillis()： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</li>
<li>void exit(int status)： 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</li>
</ul>
</li>
<li>void gc(): <ul>
<li>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li>
</ul>
</li>
<li><strong>String getProperty(String key)：</strong> <ul>
<li>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</li>
</ul>
</li>
</ul>
<img src="/post/8df0ec14/1668175927045-00a6e15f-ff7f-4639-9963-ed0d17dece4f.png" class="" title="image-20220927164120736.png">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"><span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"><span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"><span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"><span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"><span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br></pre></td></tr></table></figure>

<h2 id="7-8、Math类"><a href="#7-8、Math类" class="headerlink" title="7.8、Math类"></a>7.8、Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abs 绝对值</span><br><span class="line">acos,asin,atan,cos,sin,tan 三角函数</span><br><span class="line">sqrt 平方根</span><br><span class="line">pow(<span class="type">double</span> a,doble b) a的b次幂</span><br><span class="line">log 自然对数</span><br><span class="line">exp e为底指数</span><br><span class="line">max(<span class="type">double</span> a,<span class="type">double</span> b)</span><br><span class="line">min(<span class="type">double</span> a,<span class="type">double</span> b)</span><br><span class="line">random() 返回<span class="number">0.0</span>到<span class="number">1.0</span>的随机数</span><br><span class="line"><span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> a)</span> <span class="type">double</span>型数据a转换为<span class="type">long</span>型（四舍五入）</span><br><span class="line">toDegrees(<span class="type">double</span> angrad) 弧度—&gt;角度</span><br><span class="line">toRadians(<span class="type">double</span> angdeg) 角度—&gt;弧度</span><br></pre></td></tr></table></figure>

<h2 id="7-9、BigInteger与BigDecimal类"><a href="#7-9、BigInteger与BigDecimal类" class="headerlink" title="7.9、BigInteger与BigDecimal类"></a>7.9、BigInteger与BigDecimal类</h2><h3 id="7-9-1、BigInteger类"><a href="#7-9-1、BigInteger类" class="headerlink" title="7.9.1、BigInteger类"></a>7.9.1、BigInteger类</h3><ul>
<li> java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 </li>
<li>构造器 <ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li> 常用方法： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">abs</span><span class="params">()</span>：返回此 BigInteger 的绝对值的 BigInteger。  BigInteger <span class="title function_">add</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> + val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">subtract</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> - val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">multiply</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> * val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">divide</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> / val) 的 BigInteger。整数相除只保留整数部分。 </span><br><span class="line">BigInteger <span class="title function_">remainder</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> % val) 的 BigInteger。</span><br><span class="line">BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (<span class="built_in">this</span> / val) 后跟(<span class="built_in">this</span> % val) 的两个 BigInteger 的数组。</span><br><span class="line">BigInteger <span class="title function_">pow</span><span class="params">(<span class="type">int</span> exponent)</span> ：返回其值为(thisexponent) 的 BigInteger。</span><br></pre></td></tr></table></figure>

<h3 id="7-9-2、BigDecimal类"><a href="#7-9-2、BigDecimal类" class="headerlink" title="7.9.2、BigDecimal类"></a>7.9.2、<strong>BigDecimal类</strong></h3><ul>
<li> 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 </li>
<li> BigDecimal类<strong>支持不可变的、任意精度</strong>的有符号十进制定点数。 </li>
<li>构造器 <ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul>
</li>
<li> 常用方法 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal augend)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal subtrahend)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal multiplicand)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor, <span class="type">int</span> scale, <span class="type">int</span> roundingMode)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBigInteger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12433241123&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">// System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第八章、枚举类与注解"><a href="#第八章、枚举类与注解" class="headerlink" title="第八章、枚举类与注解"></a>第八章、枚举类与注解</h1><h2 id="8-1、内容图解"><a href="#8-1、内容图解" class="headerlink" title="8.1、内容图解"></a>8.1、内容图解</h2><img src="/post/8df0ec14/1668175938405-2741d3b5-b13f-4987-85f1-7bf534b1aacf.png" class="" title="image-20221018112702227.png">

<h2 id="8-3、枚举类的使用"><a href="#8-3、枚举类的使用" class="headerlink" title="8.3、枚举类的使用"></a>8.3、枚举类的使用</h2><p>主要内容：</p>
<ul>
<li>如何自定义枚举类</li>
<li>如何使用关键字enum定义枚举类</li>
<li>Enum类的主要方法</li>
<li>实现接口的枚举类</li>
</ul>
<h3 id="8-3-1、枚举类的使用：入门"><a href="#8-3-1、枚举类的使用：入门" class="headerlink" title="8.3.1、枚举类的使用：入门"></a>8.3.1、枚举类的使用：入门</h3><ul>
<li> 类的对象只有有限个，确定的。 </li>
<li> 当需要定义一组<strong>常量</strong>时，强烈建议用枚举类 </li>
<li>枚举类的实现 <ul>
<li>JDK1.5之前需要自定义枚举类</li>
<li>JDK 1.5 新增的 <strong>enum</strong> <strong>关键字</strong>用于定义枚举类</li>
</ul>
</li>
<li> 若枚举只有一个对象, 则可以作为一种单例模式的实现方 </li>
</ul>
<p>式。</p>
<ul>
<li><strong>枚举类的属性</strong> <ul>
<li>**枚举类对象的属性不应允许被改动， **所以应该使用 <strong>private final</strong> <strong>修饰</strong></li>
<li>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值</li>
<li>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</li>
</ul>
</li>
</ul>
<h3 id="8-3-2、自定义枚举类"><a href="#8-3-2、自定义枚举类" class="headerlink" title="8.3.2、自定义枚举类"></a>8.3.2、自定义枚举类</h3><ol>
<li> 私有化类的构造器，保证不能在类的外部创建其对象 </li>
<li> 在类的内部创建枚举类的实例。声明为：public static final </li>
<li> 对象如果有实例变量，应该声明为private final，并在构造器中初始化 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line">    <span class="built_in">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-3、使用enum定义枚举类"><a href="#8-3-3、使用enum定义枚举类" class="headerlink" title="8.3.3、使用enum定义枚举类"></a>8.3.3、使用enum定义枚举类</h3><ul>
<li>是哦呢enum定义的枚举类默认继承了java.lang.Enum类，因此不能继承其他类</li>
<li>枚举类的构造器只能使用private权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显式列出（**,** <strong>分隔</strong> <strong>;</strong> <strong>结尾</strong>)。列出的实例系统会自动添加 public static final 修饰）</li>
<li>必须在枚举类的第一行说明枚举类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-4、Enum类的主要方法"><a href="#8-3-4、Enum类的主要方法" class="headerlink" title="8.3.4、Enum类的主要方法"></a>8.3.4、Enum类的主要方法</h3><img src="/post/8df0ec14/1668175968656-25180f48-bc46-45fd-9fbb-86a02f3040ea.png" class="" title="image-20221018115527666.png">

<ul>
<li>enum类的主要方法： <ul>
<li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li>
<li>**valueOf(String str)**：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</li>
<li>**toString()**：返回当前枚举类对象常量的名称</li>
</ul>
</li>
<li> 和普通 Java 类一样，枚举类可以实现一个或多个接口 </li>
<li> 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。 </li>
<li> 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法 </li>
</ul>
<h2 id="8-4、注解的使用"><a href="#8-4、注解的使用" class="headerlink" title="8.4、注解的使用"></a>8.4、注解的使用</h2><p>主要内容：</p>
<ul>
<li> 注解(Annotation)概述 </li>
<li> 常见的Annotation示例 </li>
<li> 自定义Annotation </li>
<li> JDK中的元注解 </li>
<li> 利用反射获取注解信息（在反射部分涉及） </li>
<li> JDK 8中注解的新特性 </li>
</ul>
<h3 id="8-4-1、注解概述"><a href="#8-4-1、注解概述" class="headerlink" title="8.4.1、注解概述"></a>8.4.1、注解概述</h3><ul>
<li>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)</li>
<li>Annotation 其实就是代码里的<strong>特殊标记</strong>, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署</li>
<li>Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 <strong>“name=value</strong>” 对中。</li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li>
<li>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。</li>
</ul>
<h3 id="8-4-2、常见的Annotation示例"><a href="#8-4-2、常见的Annotation示例" class="headerlink" title="8.4.2、常见的Annotation示例"></a>8.4.2、常见的Annotation示例</h3><ul>
<li>使用Annotation时要在其前面增加 @ 符号, 并<strong>把该</strong> <strong>Annotation</strong> <strong>当成</strong>一个修饰符使用。用于修饰它支持的程序元素</li>
</ul>
<h4 id="示例一：生成文档相关的注解"><a href="#示例一：生成文档相关的注解" class="headerlink" title="示例一：生成文档相关的注解"></a>示例一：<strong>生成文档相关的注解</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@author</span> 标明开发该类模块的作者，多个作者之间使用,分割</span><br><span class="line"><span class="meta">@version</span> 标明该类模块的版本</span><br><span class="line"><span class="meta">@see</span> 参考转向，也就是相关主题</span><br><span class="line"><span class="meta">@since</span> 从哪个版本开始增加的</span><br><span class="line"><span class="meta">@param</span> 对方法中某参数的说明，如果没有参数就不能写</span><br><span class="line"><span class="meta">@return</span> 对方法返回值的说明，如果方法的返回值类型是<span class="keyword">void</span>就不能写</span><br><span class="line"><span class="meta">@exception</span> 对方法可能抛出的异常进行说明 ，如果方法没有用<span class="keyword">throws</span>显式抛出的异常就不能写</span><br><span class="line">其中</span><br><span class="line">    <span class="meta">@param</span> <span class="meta">@return</span> 和 <span class="meta">@exception</span> 这三个标记都是只用于方法的。</span><br><span class="line">    <span class="meta">@param</span>的格式要求：<span class="meta">@param</span> 形参名 形参类型 形参说明</span><br><span class="line">    <span class="meta">@return</span> 的格式要求：<span class="meta">@return</span> 返回值类型 返回值说明</span><br><span class="line">    <span class="meta">@exception</span>的格式要求：<span class="meta">@exception</span> 异常类型 异常说明</span><br><span class="line">    <span class="meta">@param</span>和<span class="meta">@exception</span>可以并列多个</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> Math.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavadocTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 程序的主方法，程序的入口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args String[] 命令行参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 求圆面积的方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> radius double 半径值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> double 圆的面积</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例二：在编译时进行格式检查-JDK内置的三个基本注解"><a href="#示例二：在编译时进行格式检查-JDK内置的三个基本注解" class="headerlink" title="示例二：在编译时进行格式检查(JDK内置的三个基本注解)"></a>示例二：在编译时进行格式检查(JDK内置的三个基本注解)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>: 限定重写父类方法, 该注解只能用于方法</span><br><span class="line"><span class="meta">@Deprecated</span>: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</span><br><span class="line"><span class="meta">@SuppressWarnings</span>: 抑制编译器警告</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;重写的toString方法()&quot;</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例三：跟踪代码依赖性，实现替代配置文件功能"><a href="#示例三：跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="示例三：跟踪代码依赖性，实现替代配置文件功能"></a>示例三：跟踪代码依赖性，实现替代配置文件功能</h4><ul>
<li>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">现在，直接使用注解即可实现部署</span><br><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span><br><span class="line">    ServletException, IOException &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span><br><span class="line">    ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">之前：web.xml进行部署</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/login&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>spring框架中关于“事务”的管理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">现在：使用注解</span><br><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(String username, String isbn)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询书的单价</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">    <span class="comment">//2. 更新库存</span></span><br><span class="line">    bookShopDao.updateBookStock(isbn);</span><br><span class="line">    <span class="comment">//3. 更新用户的余额</span></span><br><span class="line">    bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">之前：web.xml进行部署</span><br><span class="line">&lt;!-- 配置事务属性 --&gt;</span><br><span class="line">    &lt;tx:advice transaction-manager=<span class="string">&quot;dataSourceTransactionManager&quot;</span> id=<span class="string">&quot;txAdvice&quot;</span>&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">        &lt;!-- 配置每个方法使用的事务属性 --&gt;</span><br><span class="line">        &lt;tx:method name=<span class="string">&quot;buyBook&quot;</span> propagation=<span class="string">&quot;REQUIRES_NEW&quot;</span></span><br><span class="line">            isolation=<span class="string">&quot;READ_COMMITTED&quot;</span> read-only=<span class="string">&quot;false&quot;</span> timeout=<span class="string">&quot;3&quot;</span> /&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-3、自定义Annotation"><a href="#8-4-3、自定义Annotation" class="headerlink" title="8.4.3、自定义Annotation"></a>8.4.3、自定义Annotation</h3><ul>
<li>定义新的 Annotation 类型使用 <a href="/interface">@interface </a> 关键字</li>
<li>自定义注解自动继承了java.lang.annotation.Annotation接口</li>
<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。</li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字</li>
<li>如果<strong>只有</strong>一个参数成员，建议使用参数名为value</li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”</li>
<li>没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation</li>
<li>注意：自定义注解<strong>必须配上注解的信息处理流程（反射实</strong>现）才有意义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;尚硅谷&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> MyAnnotationTest.class;</span><br><span class="line">            <span class="type">Annotation</span> <span class="variable">a</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">m</span> <span class="operator">=</span> (MyAnnotation) a;</span><br><span class="line">            <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> m.value();</span><br><span class="line">            System.out.println(info);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">        String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;auguigu&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-4、JDK中的元注解"><a href="#8-4-4、JDK中的元注解" class="headerlink" title="8.4.4、JDK中的元注解"></a>8.4.4、JDK中的元注解</h3><ul>
<li> JDK 的元 Annotation 用于修饰其他 Annotation 定义 </li>
<li> JDK5.0提供了4个标准的meta-annotation类型，分别是： </li>
<li> <strong>Retention</strong> </li>
<li> <strong>Target</strong> </li>
<li> <strong>Documented</strong> </li>
<li> <strong>Inherited</strong> </li>
</ul>
<p>元数据的理解：</p>
<p>String name = “atguigu”;</p>
<h4 id="8-4-4-1、-Retention"><a href="#8-4-4-1、-Retention" class="headerlink" title="8.4.4.1、@Retention "></a>8.4.4.1、<a href="/Retention">@Retention </a></h4><ul>
<li>@Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, <a href="/Rentention">@Rentention </a> 包含一个 <strong>RetentionPolicy</strong> 类型的成员变量, 使用<a href="/Rentention">@Rentention </a> 时必须为该 value 成员变量指定值:  <ul>
<li>**RetentionPolicy.<strong><strong>SOURCE</strong></strong>:**在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释</li>
<li>**RetentionPolicy.**<strong>CLASS</strong>:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注解。 这是默认值</li>
<li><strong>RetentionPolicy.<strong><strong>RUNTIME</strong></strong>:<strong>在运行时有效（即运行时保留），</strong>当运行</strong> <strong>Java程序时, JVM 会保留注释。程序可以通过反射获取该注释</strong></li>
</ul>
</li>
</ul>
<img src="/post/8df0ec14/1668175983196-016b4c53-0590-4106-92cc-00732b12f7af.png" class="" title="image-20221024124024635.png">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span>&#123;</span><br><span class="line">    SOURCE,</span><br><span class="line">    CLASS,</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation1&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-4-2、-Target"><a href="#8-4-4-2、-Target" class="headerlink" title="8.4.4.2、@Target "></a>8.4.4.2、<a href="/Target">@Target </a></h4><ul>
<li><a href="/Target">**@Target **</a>** **: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 <a href="/Target">@Target </a> 也包含一个名为 value 的成员变量。 </li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th></th>
<th>取值</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CONSTRUCTOR</td>
<td>用于描述构造器</td>
<td>PACKAGE</td>
<td>用于描述包</td>
</tr>
<tr>
<td>FIELD</td>
<td>用于描述域</td>
<td>PARAMETER</td>
<td>用户描述参数</td>
</tr>
<tr>
<td>LOCAL_VARIABLE</td>
<td>用于描述局部变量</td>
<td>TYPE</td>
<td>用于描述类、接口（包括注解类型）或enum声明</td>
</tr>
<tr>
<td>METHOD</td>
<td>用于描述方法</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="8-4-4-3、-Documented"><a href="#8-4-4-3、-Documented" class="headerlink" title="8.4.4.3、@Documented "></a>8.4.4.3、<a href="/Documented">@Documented </a></h4><ul>
<li>@Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 <ul>
<li>定义为Documented的注解必须设置Retention值为RUNTIME。</li>
</ul>
</li>
</ul>
<h4 id="8-4-4-4、-Inherited"><a href="#8-4-4-4、-Inherited" class="headerlink" title="8.4.4.4、@Inherited "></a>8.4.4.4、<a href="/Inherited">@Inherited </a></h4><ul>
<li>@Inherited: 被它修饰的 Annotation 将具有==<strong>继承性</strong>==。如果某个类使用了被<a href="/Inherited">@Inherited </a> 修饰的 Annotation, 则其子类将自动具有该注解。  <ul>
<li>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解</li>
<li>实际应用中，使用较少</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://febsnail.github.io">FebSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://febsnail.github.io/post/8df0ec14.html">https://febsnail.github.io/post/8df0ec14.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://febsnail.github.io" target="_blank">二月蜗牛2</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/7785aa0a.html" title="Java学习3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java学习3</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FebSnail</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章、Java语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">Java基础知识图解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">第二章、Java基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 变量与运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">2.1.1 关键字与保留字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.0.1.1.</span> <span class="toc-text">static解析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">2.1.0.1.1.1.</span> <span class="toc-text">1、static关键字的用途</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-number">2.1.0.1.1.2.</span> <span class="toc-text">2、static关键字的误区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">2.1.2 标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">2.1.3 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">2.1.0.3.1.</span> <span class="toc-text">变量的分类：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9Abyte%E3%80%81short%E3%80%81int%E3%80%81long"><span class="toc-number">2.1.0.3.2.</span> <span class="toc-text">整数类型：byte、short、int、long</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%EF%BC%9Afloat%E3%80%81double"><span class="toc-number">2.1.0.3.3.</span> <span class="toc-text">浮点类型：float、double</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%EF%BC%9Achar"><span class="toc-number">2.1.0.3.4.</span> <span class="toc-text">字符类型：char</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3ASCII-%E7%A0%81"><span class="toc-number">2.1.0.3.5.</span> <span class="toc-text">了解ASCII 码:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%EF%BC%9Aboolean"><span class="toc-number">2.1.0.3.6.</span> <span class="toc-text">布尔类型：boolean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.0.3.7.</span> <span class="toc-text">基本数据类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%9AString"><span class="toc-number">2.1.0.3.8.</span> <span class="toc-text">字符串类型：String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">2.1.0.3.9.</span> <span class="toc-text">强制类型转换：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%96%B2%E8%BF%9B%E5%88%B6%EF%BC%9A"><span class="toc-number">2.1.0.3.10.</span> <span class="toc-text">▲进制：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%98%86%E6%B3%A8%EF%BC%9A%E8%BF%9B%E5%88%B6%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%E9%9C%80%E8%A6%81%E5%86%8D%E5%8E%BB%E4%BA%86%E8%A7%A3%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%9A%82%E6%97%B6%E7%95%99%E7%9D%80"><span class="toc-number">2.1.0.3.11.</span> <span class="toc-text">☆注：进制的具体内容需要再去了解学习，暂时留着</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.0.4.</span> <span class="toc-text">2.1.4 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.0.4.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">2.1.0.4.2.</span> <span class="toc-text">赋值运算符：&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">2.1.0.4.3.</span> <span class="toc-text">比较运算符：&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.0.4.4.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%98%85%E2%80%9C-amp-%E2%80%9D%E5%92%8C%E2%80%9C-amp-amp-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.1.0.4.4.1.</span> <span class="toc-text">★“&amp;”和“&amp;&amp;”的区别：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%98%85%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%8C%E7%90%86%EF%BC%8C-%E8%A1%A8%E7%A4%BA%EF%BC%9A%E5%BD%93%E5%B7%A6%E8%BE%B9%E4%B8%BA%E7%9C%9F%EF%BC%8C%E5%8F%B3%E8%BE%B9%E4%B8%8D%E5%8F%82%E4%B8%8E%E8%BF%90%E7%AE%97%E3%80%82"><span class="toc-number">2.1.0.4.4.2.</span> <span class="toc-text">★“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E8%BE%83%E5%B0%91%E6%8E%A5%E8%A7%A6%EF%BC%8C%E9%9C%80%E8%A6%81%E5%86%8D%E5%9B%9E%E5%A4%B4%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="toc-number">2.1.0.4.5.</span> <span class="toc-text">位运算符（较少接触，需要再回头学习）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.0.4.6.</span> <span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9A"><span class="toc-number">2.1.0.4.7.</span> <span class="toc-text">运算符的优先级：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.1.0.5.</span> <span class="toc-text">2.1.5 程序流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.0.5.0.1.</span> <span class="toc-text">顺序结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.0.5.0.2.</span> <span class="toc-text">分支结构</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-case%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">switch-case结构 </span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.0.0.0.1.</span> <span class="toc-text">循环结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A-break%E3%80%81continue"><span class="toc-number">2.2.0.0.0.2.</span> <span class="toc-text">特殊关键字的使用： break、continue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E8%AF%B4%E6%98%8E"><span class="toc-number">2.2.0.0.0.3.</span> <span class="toc-text">特殊流程控制语句说明</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">第三章、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">3.1   概述：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2  一维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">一维数组的声明方式： </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E7%9A%84%E5%85%83%E7%B4%A0%E7%9B%B8%E5%BD%93%E4%BA%8E%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%95%B0%E7%BB%84%E4%B8%80%E7%BB%8F-%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B9%9F%E8%A2%AB%E6%8C%89%E7%85%A7%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%90%8C%E6%A0%B7%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A2%AB%E9%9A%90%E5%BC%8F-%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="toc-number">3.4.</span> <span class="toc-text">数组是引用类型，它的元素相当于类的成员变量，因此数组一经 分配空间，其中的每个元素也被按照成员变量同样的方式被隐式 初始化。例如： </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.5.</span> <span class="toc-text">3.3  多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">3.4 数组中设计的常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="toc-number">3.6.1.</span> <span class="toc-text">二分查找算法演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.2.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%98%85%E5%8D%81%E5%A4%A7%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E8%AF%A6%E7%BB%86%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">★十大内部排序算法（详细在数据结构中学习）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB-%E4%BD%BF%E7%94%A8"><span class="toc-number">3.7.</span> <span class="toc-text">3.5  Arrays工具类 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-number">3.8.</span> <span class="toc-text">3.6 数组使用中的常见异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%84%9A%E6%A0%87%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8-ArrayIndexOutOfBoundsException"><span class="toc-number">3.8.0.1.</span> <span class="toc-text">数组脚标越界异常(ArrayIndexOutOfBoundsException)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8-NullPointerException"><span class="toc-number">3.8.0.2.</span> <span class="toc-text">空指针异常(NullPointerException)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">第四章、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">4.1、 面向过程与面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.</span> <span class="toc-text">4.2、类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">4.2.1.</span> <span class="toc-text">Java类及类的成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">4.3、对象的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%9A%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">4.3.1.</span> <span class="toc-text">对象的创建和使用：内存解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">4.4、 类的成员之一：属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E3%80%81%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%8C%EF%BC%9A-%E6%96%B9%E6%B3%95-method"><span class="toc-number">4.5.</span> <span class="toc-text">4.5、类的成员之二： 方法(method)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6%E3%80%81%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">4.6.</span> <span class="toc-text">4.6、方法深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E6%96%B9%E6%B3%951%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD-overload"><span class="toc-number">4.6.1.</span> <span class="toc-text">再谈方法1：方法的重载(overload)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E6%96%B9%E6%B3%952%EF%BC%9A%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82"><span class="toc-number">4.6.2.</span> <span class="toc-text">再谈方法2：可变个数的形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-number">4.6.3.</span> <span class="toc-text">★方法参数的值传递机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.4.</span> <span class="toc-text">递归方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7%E3%80%81-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%EF%BC%9A-%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="toc-number">4.7.</span> <span class="toc-text">4.7、 面向对象特征之一： 封装与隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">4.7.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-number">4.7.2.</span> <span class="toc-text">信息的封装和隐藏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.8.</span> <span class="toc-text">四种访问权限修饰符 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%89%EF%BC%9A-%E6%9E%84%E9%80%A0%E5%99%A8-%E6%88%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.1.</span> <span class="toc-text">类的成员之三： 构造器(或构造方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">构造器的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E9%87%8D%E8%BD%BD"><span class="toc-number">4.8.1.2.</span> <span class="toc-text">构造器重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B"><span class="toc-number">4.8.1.3.</span> <span class="toc-text">总结：属性赋值过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%EF%BC%9AJavaBean"><span class="toc-number">4.8.1.4.</span> <span class="toc-text">拓展知识：JavaBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%EF%BC%9AUML%E7%B1%BB%E5%9B%BE"><span class="toc-number">4.8.1.5.</span> <span class="toc-text">拓展知识：UML类图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Athis%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.8.2.</span> <span class="toc-text">9.关键字：this的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Apackage%E3%80%81-import%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.8.3.</span> <span class="toc-text">10.关键字：package、 import的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.3.1.</span> <span class="toc-text">MVC设计模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%BA%8C%EF%BC%9A-%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-number">4.9.</span> <span class="toc-text">4.8、面向对象特征之二： 继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">4.9.0.1.</span> <span class="toc-text">简介:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7%E4%BD%9C%E7%94%A8"><span class="toc-number">4.9.0.1.1.</span> <span class="toc-text">继承性作用:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7%E8%A7%84%E5%88%99"><span class="toc-number">4.9.0.1.2.</span> <span class="toc-text">继承性规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">4.9.0.1.3.</span> <span class="toc-text">重写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-number">4.9.0.2.</span> <span class="toc-text">简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%EF%BC%9A"><span class="toc-number">4.9.0.3.</span> <span class="toc-text">要求：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">4.9.0.4.</span> <span class="toc-text">代码解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97super"><span class="toc-number">4.9.1.</span> <span class="toc-text">2. 关键字super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">4.9.2.</span> <span class="toc-text">3.  子类对象实例化过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">4.10.</span> <span class="toc-text">4.9、面向对象特征之三：多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E5%AF%B9%E6%AF%94"><span class="toc-number">4.10.1.</span> <span class="toc-text">4.9.1、方法的重载与重写对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-2%E3%80%81%E5%A4%9A%E6%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">4.10.2.</span> <span class="toc-text">4.9.2、多态小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-3%E3%80%81instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.10.3.</span> <span class="toc-text">4.9.3、instanceof操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-4%E3%80%81%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88Casting%EF%BC%89"><span class="toc-number">4.10.4.</span> <span class="toc-text">4.9.4、对象类型转换（Casting）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10%E3%80%81Object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.11.</span> <span class="toc-text">4.10、Object类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-1%E3%80%81%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-number">4.11.1.</span> <span class="toc-text">4.10.1、主要结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-2%E3%80%81-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8Eequals%E6%96%B9%E6%B3%95"><span class="toc-number">4.11.2.</span> <span class="toc-text">4.10.2、&#x3D;&#x3D;操作符与equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-3%E3%80%81-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.11.3.</span> <span class="toc-text">4.10.3、&#x3D;&#x3D;和equals的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-4%E3%80%81toString%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">4.11.4.</span> <span class="toc-text">4.10.4、toString（）方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-5%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.11.5.</span> <span class="toc-text">4.10.5、包装类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.12.</span> <span class="toc-text">包装类用法举例 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%EF%BC%9A"><span class="toc-number">4.12.1.</span> <span class="toc-text">问：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9F%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AC%A1%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.12.1.1.</span> <span class="toc-text">如何实现向下转型？需要注意什么问题？如何解决次问题？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%BA%E8%BD%AC%E7%AC%A6"><span class="toc-number">4.13.</span> <span class="toc-text">使用强转符 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-number">4.13.0.1.</span> <span class="toc-text">&#x3D;&#x3D; 和 equals() 有何区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E3%80%81%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">4.13.0.2.</span> <span class="toc-text">自动拆箱、自动装箱</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Astatic"><span class="toc-number">4.14.</span> <span class="toc-text">4.11、关键字：static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-1%E3%80%81%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">4.14.1.</span> <span class="toc-text">4.11.1、修饰属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-2%E3%80%81%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.14.2.</span> <span class="toc-text">4.11.2、修饰方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-3%E3%80%81%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%A3%B0%E6%98%8E%E4%B8%BAstatic"><span class="toc-number">4.14.3.</span> <span class="toc-text">4.11.3、如何确定是否需要声明为static</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.15.</span> <span class="toc-text">单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">4.15.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">4.15.2.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.15.3.</span> <span class="toc-text">单例模式的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.15.4.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12%E3%80%81main%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">4.16.</span> <span class="toc-text">4.12、main方法的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13%E3%80%81-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">4.17.</span> <span class="toc-text">4.13、 类的成员之四：代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Afinal"><span class="toc-number">4.18.</span> <span class="toc-text">4.14、关键字：final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-15%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.19.</span> <span class="toc-text">4.15、抽象类与抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-TemplateMethod"><span class="toc-number">4.19.1.</span> <span class="toc-text">多态的应用：模板方法设计模式(TemplateMethod)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-16%E3%80%81-%E6%8E%A5%E5%8F%A3-interface"><span class="toc-number">4.20.</span> <span class="toc-text">4.16、 接口(interface)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89Java%E7%B1%BB%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%EF%BC%9A%E5%85%88%E5%86%99extends%EF%BC%8C%E5%90%8E%E5%86%99implements"><span class="toc-number">4.21.</span> <span class="toc-text">定义Java类的语法格式：先写extends，后写implements </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy"><span class="toc-number">4.21.1.</span> <span class="toc-text">接口的应用：代理模式(Proxy)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">第五章、异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81-%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">5.1、 异常概述与异常体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2、 常见异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%80%E3%80%81try-catch-finally"><span class="toc-number">5.3.</span> <span class="toc-text">5.3、 异常处理机制一、try-catch-finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BA%8C%E3%80%81throws-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">5.4、 异常处理机制二、throws + 异常类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81-%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">5.5.</span> <span class="toc-text">5.5、 手动抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%96%B25-6-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">5.6.</span> <span class="toc-text">▲5.6 用户自定义异常类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 用户自定义异常类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">第六章 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-0%E3%80%81%E5%86%85%E5%AE%B9%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.1.</span> <span class="toc-text">6.0、内容图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">6.1、基本概念：程序、进程、线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1%E3%80%81%E5%8D%95%E6%A0%B8CPU%E5%92%8C%E5%A4%9A%E6%A0%B8CPU%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.1.1、单核CPU和多核CPU的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2%E3%80%81%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.1.2、并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3%E3%80%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.1.3、使用多线程的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.1.4、多线程使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">6.2、线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.2.1、创建和启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2%E3%80%81API%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.2.2、API中创建线程的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-1%E3%80%81%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">6.2.2.1、方式一：继承Thread类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-2%E3%80%81%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">6.2.2.2、方式二：实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3%E3%80%81%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.2.3、继承方式和实现方式的联系与区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4%E3%80%81Thread%E7%9B%B8%E5%85%B3API"><span class="toc-number">6.3.4.</span> <span class="toc-text">6.2.4、Thread相关API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">6.3.5.</span> <span class="toc-text">6.2.5、线程的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.3.6.</span> <span class="toc-text">6.2.6、线程的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-7%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.3.7.</span> <span class="toc-text">6.2.7、线程的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.4.</span> <span class="toc-text">6.3、线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">6.5.</span> <span class="toc-text">6.4、线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1%E3%80%81Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.1.</span> <span class="toc-text">6.4.1、Synchronized的使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2%E3%80%81%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-number">6.5.2.</span> <span class="toc-text">6.4.2、同步机制中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-1%E3%80%81%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">6.4.2.1、同步的范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-2%E3%80%81%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">6.4.2.2、释放锁的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-3%E3%80%81%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.5.2.3.</span> <span class="toc-text">6.4.2.3、不会释放锁的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">6.5.3.</span> <span class="toc-text">6.4.3、单例设计模式之懒汉式(线程安全)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.4.</span> <span class="toc-text">6.4.4、线程的死锁问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-5%E3%80%81Lock-%E9%94%81"><span class="toc-number">6.5.5.</span> <span class="toc-text">6.4.5、Lock(锁)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-6%E3%80%81synchronized-%E4%B8%8E-Lock-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.5.6.</span> <span class="toc-text">6.4.6、synchronized 与 Lock 的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">6.6.</span> <span class="toc-text">6.5、线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1%E3%80%81wait%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.0.1.</span> <span class="toc-text">6.5.1、wait（）方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-1-1%E3%80%81wait%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Esleep%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.0.1.1.</span> <span class="toc-text">6.5.1.1、wait（）方法与sleep方法的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2%E3%80%81notify-notifyAll"><span class="toc-number">6.6.0.2.</span> <span class="toc-text">6.5.2、notify()&#x2F;notifyAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-3%E3%80%81%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">6.6.0.3.</span> <span class="toc-text">6.5.3、经典例题：生产者&#x2F;消费者问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6%E3%80%81JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">6.6.1.</span> <span class="toc-text">6.6、JDK5.0新增线程创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1%E3%80%81%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.6.1.1.</span> <span class="toc-text">6.6.1、新增方式一：实现Callable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2%E3%80%81%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.6.1.2.</span> <span class="toc-text">6.6.2、新增方式二：使用线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3api"><span class="toc-number">6.6.1.2.1.</span> <span class="toc-text">6.6.2.1、线程池相关api</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">第七章 常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-0%E3%80%81%E5%86%85%E5%AE%B9%E5%9B%BE%E8%A7%A3"><span class="toc-number">7.1.</span> <span class="toc-text">7.0、内容图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%EF%BC%9AString"><span class="toc-number">7.2.</span> <span class="toc-text">7.1、字符串相关的类：String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1%E3%80%81String%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.1.1、String的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2%E3%80%81String%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.1.2、String使用陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3%E3%80%81string%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.1.3、string常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%EF%BC%9AString%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.2.4.</span> <span class="toc-text">7.1.4、字符串相关的类：String与基本数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-5%E3%80%81String%E8%BD%AC%E5%8C%96%E4%B8%BAStringBuffer%E3%80%81StringBuilder"><span class="toc-number">7.2.5.</span> <span class="toc-text">7.1.5、String转化为StringBuffer、StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-6%E3%80%81StringBuffer%E3%80%81StringBuilder-%E8%BD%AC%E6%8D%A2%E4%B8%BAString"><span class="toc-number">7.2.6.</span> <span class="toc-text">7.1.6、StringBuffer、StringBuilder 转换为String</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%EF%BC%9AStringBuffer%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">7.2、字符串相关的类：StringBuffer类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1%E3%80%81StringBuffer%E7%B1%BB%E7%89%B9%E6%80%A7"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.2.1、StringBuffer类特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2%E3%80%81StringBuffer%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.2.2、StringBuffer类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%EF%BC%9AStringBuilder%E7%B1%BB"><span class="toc-number">7.4.</span> <span class="toc-text">7.3、字符串相关的类：StringBuilder类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E3%80%81JDK8%E4%B9%8B%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-number">7.5.</span> <span class="toc-text">7.4、JDK8之前日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1%E3%80%81-java-lang-System%E7%B1%BB"><span class="toc-number">7.5.1.</span> <span class="toc-text">7.4.1、 java.lang.System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2%E3%80%81java-util-Date%E7%B1%BB"><span class="toc-number">7.5.2.</span> <span class="toc-text">7.4.2、java.util.Date类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3%E3%80%81SimpleDateFormat%E7%B1%BB"><span class="toc-number">7.5.3.</span> <span class="toc-text">7.4.3、SimpleDateFormat类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E3%80%81JDK8%E4%B8%AD%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-number">7.6.</span> <span class="toc-text">7.5、JDK8中新日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1%E3%80%81-LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.6.1.</span> <span class="toc-text">7.5.1、 LocalDate、LocalTime、LocalDateTime的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2%E3%80%81%E7%9E%AC%E6%97%B6%EF%BC%9AInstant"><span class="toc-number">7.6.2.</span> <span class="toc-text">7.5.2、瞬时：Instant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%90%E6%97%A5%E6%9C%9F%E6%88%96%E6%97%B6%E9%97%B4"><span class="toc-number">7.6.3.</span> <span class="toc-text">7.5.3、格式化与解析日期或时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-4%E3%80%81%E5%85%B6%E4%BB%96api"><span class="toc-number">7.6.4.</span> <span class="toc-text">7.5.4、其他api</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6%E3%80%81Java%E6%AF%94%E8%BE%83%E5%99%A8%EF%BC%88%E4%BB%85%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">7.6、Java比较器（仅了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1%E3%80%81%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%EF%BC%9Ajava-lang-Comparable"><span class="toc-number">7.7.1.</span> <span class="toc-text">7.6.1、方式一：自然排序：java.lang.Comparable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2%E3%80%81%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%EF%BC%9Ajava-util-Comparator"><span class="toc-number">7.7.2.</span> <span class="toc-text">7.6.2、方式二：定制排序：java.util.Comparator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7%E3%80%81System%E7%B1%BB"><span class="toc-number">7.8.</span> <span class="toc-text">7.7、System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8%E3%80%81Math%E7%B1%BB"><span class="toc-number">7.9.</span> <span class="toc-text">7.8、Math类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9%E3%80%81BigInteger%E4%B8%8EBigDecimal%E7%B1%BB"><span class="toc-number">7.10.</span> <span class="toc-text">7.9、BigInteger与BigDecimal类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-1%E3%80%81BigInteger%E7%B1%BB"><span class="toc-number">7.10.1.</span> <span class="toc-text">7.9.1、BigInteger类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-2%E3%80%81BigDecimal%E7%B1%BB"><span class="toc-number">7.10.2.</span> <span class="toc-text">7.9.2、BigDecimal类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">第八章、枚举类与注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81%E5%86%85%E5%AE%B9%E5%9B%BE%E8%A7%A3"><span class="toc-number">8.1.</span> <span class="toc-text">8.1、内容图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.2.</span> <span class="toc-text">8.3、枚举类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A%E5%85%A5%E9%97%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.3.1、枚举类的使用：入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.3.2、自定义枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3%E3%80%81%E4%BD%BF%E7%94%A8enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">8.2.3.</span> <span class="toc-text">8.3.3、使用enum定义枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4%E3%80%81Enum%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.4.</span> <span class="toc-text">8.3.4、Enum类的主要方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4%E3%80%81%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">8.4、注解的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1%E3%80%81%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">8.3.1.</span> <span class="toc-text">8.4.1、注解概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84Annotation%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.3.2.</span> <span class="toc-text">8.4.2、常见的Annotation示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">示例一：生成文档相关的注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5-JDK%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">示例二：在编译时进行格式检查(JDK内置的三个基本注解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E8%B7%9F%E8%B8%AA%E4%BB%A3%E7%A0%81%E4%BE%9D%E8%B5%96%E6%80%A7%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9B%BF%E4%BB%A3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">8.3.2.3.</span> <span class="toc-text">示例三：跟踪代码依赖性，实现替代配置文件功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Annotation"><span class="toc-number">8.3.3.</span> <span class="toc-text">8.4.3、自定义Annotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-4%E3%80%81JDK%E4%B8%AD%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.3.4.</span> <span class="toc-text">8.4.4、JDK中的元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-4-1%E3%80%81-Retention"><span class="toc-number">8.3.4.1.</span> <span class="toc-text">8.4.4.1、@Retention </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-4-2%E3%80%81-Target"><span class="toc-number">8.3.4.2.</span> <span class="toc-text">8.4.4.2、@Target </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-4-3%E3%80%81-Documented"><span class="toc-number">8.3.4.3.</span> <span class="toc-text">8.4.4.3、@Documented </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-4-4%E3%80%81-Inherited"><span class="toc-number">8.3.4.4.</span> <span class="toc-text">8.4.4.4、@Inherited </span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/8df0ec14.html" title="Java学习">Java学习</a><time datetime="2023-03-29T07:13:23.000Z" title="发表于 2023-03-29 15:13:23">2023-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/7785aa0a.html" title="Java学习3">Java学习3</a><time datetime="2023-03-29T06:24:24.000Z" title="发表于 2023-03-29 14:24:24">2023-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/829a9c.html" title="Java学习2">Java学习2</a><time datetime="2023-03-29T06:09:27.000Z" title="发表于 2023-03-29 14:09:27">2023-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/6782be63.html" title="Docker学习">Docker学习</a><time datetime="2023-03-29T05:31:54.000Z" title="发表于 2023-03-29 13:31:54">2023-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/4a17b156.html" title="Hello World">Hello World</a><time datetime="2023-03-28T06:54:17.573Z" title="发表于 2023-03-28 14:54:17">2023-03-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By FebSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>